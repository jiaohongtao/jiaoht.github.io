<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jenkins搭建]]></title>
    <url>%2F2020%2Fjenkins%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[下载jenkins(这个是清华的源)： wget https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/jenkins-2.190.2-1.1.noarch.rpm 提示：如果没有wget，执行后再下载jenkins的rpm包：yum install -y wget 安装jenkins：rpm -ivh jenkins-2.190.2-1.1.noarch.rpm 启动Jenkins：systemctl start jenkins 问题解决： Jenkins登录页面密码查看路径：cat /var/lib/jenkins/secrets/initialAdminPassword 查看admin密码,这里是加密的密码：cat /var/lib/jenkins/users/admin_*/config.xml 1&lt;passwordHash&gt;#jbcrypt:$2a$10$MiIVR0rr/UhQBqT.bBq0QehTiQVqgNpUGyWW2nJObaVAM/2xSQdSq&lt;/passwordHash&gt; 如果忘记密码需要修改的话，可以将我的这个替换成你的这里部分重启，密码为123456。 如果提示该Jenkins示例似乎离线：则需要将更新的源替换，我使用的是清华的源：网页输入：http://ip:port/pluginManager/advanced修改最下面的URL为：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 如果需要java环境，则安装jdk：yum install -y java-1.8.0-openjdk-devel.x86_64]]></content>
  </entry>
  <entry>
    <title><![CDATA[idea报错：java.lang.UnsatisfiedLinkError: Could not load library. Reasons: [no leveldbjni64-1.8 in java]]></title>
    <url>%2F2019%2Fidea%E6%8A%A5%E9%94%99%EF%BC%9Ajava-lang-UnsatisfiedLinkError-Could-not-load-library-Reasons-no-leveldbjni64-1-8-in-java%2F</url>
    <content type="text"><![CDATA[java.lang.UnsatisfiedLinkError: Could not load library. Reasons: [no leveldbjni64-1.8 in java.library.path, no leveldbjni-1.8 in java.library.path, C:\Windows\System32\leveldbjni.dll: Can’t find dependent libraries, C:\Users\dajiaotao\AppData\Local\Temp\leveldbjni-64-1-1989621817943305095.8: Can’t find dependent libraries] ================================================== 这个折磨我两天的问题，就是少了dll。。。。 下载网址：http://www.onlinedown.net/soft/120082.htm]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java.lang.UnsatisfiedLinkError</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javabean作用和优势,什么时候该对数据封装?]]></title>
    <url>%2F2019%2Fjavabean%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BC%98%E5%8A%BF-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[javabean作用和优势,什么时候该对数据封装? 参考（侵权删）：https://zhidao.baidu.com/question/51726153.html 首先这是一个编程思想，也就是所谓‘面向对象’的问题。javabean本身是一个java对象，他对数据进行的封装。我们需要访问数据的时候只要访问这个对象就可以了。其次，如果你的表单数据比较少还好，如果多一些，比如10个，那么你在servlet的方法调用，比如调用数据库insert操作，你要建立一个具有10个参数的方法吗？还是创建一个只有一个javabean做参数的方法简单？在你的例子中，比如A页面提交跳转如B页面，期间A页面的表单数据封装进一个javabean，那么在B页面只需要访问这个javabean，然后调用其相关get方法就可以了。而如果不用javabean，你在servlet终究要不厌其烦的request.setParameter().而且，将来你肯定会接触到一些数据库持久层的开源框架，现在用的最多的比如hibernate，他对数据库的增删改查全是基于javabean的，比如你要保存一个student的学号，姓名，性别的信息。原来的做法是insert into t_student (id,name,sex) value(1,’jack’,1).而使用Hibernate这类框架，只需要调用一个方法save(student).其中student就是一个javabean,它具有3个成员变量，id,name,sex.是不是很方便？扯远了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>javabean作用和优势</tag>
        <tag>数据封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA、WebStorm永久激活]]></title>
    <url>%2F2019%2FIDEA%E3%80%81WebStorm%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[Web Storm 激活步骤与此相同 版权声明：感谢博主 张未-大道五十,天衍四九,人遁其一-成都,中国 本文转自：https://blog.weechang.xyz/2018/09/21/IDEA、WebStorm最新永久激活方式/ 步骤1.下载插件2.安装插件3.修改配置 下载插件首先下载插件jar包 http://idea.lanyus.com/jar/JetbrainsCrack-3.1-release-enc.jar 安装插件然后将插件移动到 IDEA 安装目录的bin下。如我的目录 %IntelliJ IDEA%\bin 修改配置修改 IDEA 安装bin目录下的 idea64.exe.vmoptions 或者 idea.exe.vmoptions 具体修改哪一个看自己操作系统是64 位还是32位。64位修改 idea64.exe.vmoptions ， 32位修改 idea.exe.vmoptions。 然后在文件末尾添加上（其中 D:\idea\IntelliJ IDEA 2018.2.4\bin\JetbrainsCrack-3.1-release-enc.jar 为插件的安装路径和文件名。注意，目录和文件名一定要一直，不然IDEA不能启动） 1-javaagent:D:\idea\IntelliJ IDEA 2018.2.4\bin\JetbrainsCrack-3.1-release-enc.jar 重启IDEA、填写CODE重启IDEA，选择Activation Code填写激活码 123456789101112131415161718192021222324ThisCrackLicenseId-&#123; &quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;, &quot;licenseeName&quot;:&quot;你想填的用户名&quot;, &quot;assigneeName&quot;:&quot;&quot;, &quot;assigneeEmail&quot;:&quot;你想填的邮箱&quot;, &quot;licenseRestriction&quot;:&quot;For This Crack, Only Test! Please support genuine!!!&quot;, &quot;checkConcurrentUse&quot;:false, &quot;products&quot;:[ &#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125; ], &quot;hash&quot;:&quot;2911276/0&quot;, &quot;gracePeriodDays&quot;:7, &quot;autoProlongated&quot;:false&#125; 激活OK，至此为止，你的IDEA 就激活成功，又可以继续浪了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于postman的请求参数的格式问题]]></title>
    <url>%2F2019%2F%E5%85%B3%E4%BA%8Epostman%E7%9A%84%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[版权声明：创作不易，转载请附上本文地址https://blog.csdn.net/weixin_40375601/article/details/85121974 注意点： 1.GET请求 2.参数格式为params : { “xx” : “xx” } 3.Cookie的JSESSIONID 1.错误示例： 2.正确示例：]]></content>
      <categories>
        <category>Miexd</category>
      </categories>
      <tags>
        <tag>postman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper连接不上/Session 0x0 for server null, unexpected error, closing socket connection]]></title>
    <url>%2F2019%2Fzookeeper%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A-Session-0x0-for-server-null-unexpected-error-closing-socket-connection%2F</url>
    <content type="text"><![CDATA[好像是Linux重启导致zookeeper端口出了问题 设置默认接口区域，立即生效无需重启（这个好像是重置所有端口，慎用!!!，不过我确实是用这个解决了,然后重新打开需要的端口）firewall-cmd --set-default-zone=public打开端口命令： firewall-cmd --add-port=端口号/tcp]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>Linux端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Linux服务器设置静态IP的方法,并且ping通外网]]></title>
    <url>%2F2019%2F%E4%B8%BALinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP%E7%9A%84%E6%96%B9%E6%B3%95-%E5%B9%B6%E4%B8%94ping%E9%80%9A%E5%A4%96%E7%BD%91%2F</url>
    <content type="text"><![CDATA[参考https://www.cnblogs.com/freeweb/p/5335973.html 这里以CentOS 7系列为例设置静态IP，原来RedHat系列的Linux发行版可以通过setup工具方便的设置静态IP，但是在版本7之后setup工具的功能就逐渐减弱了，所以这时候采用修改配置文件的方式来设置静态IP，方法如下： 首先注意，路由网关处必须设置可以配置静态IP或者使用指定IP绑定MAC才可以配置，否则配置不成功，不要盲目的配置 网络配置的配置文件在/etc/sysconfig/network-scripts/下，文件名前缀为ifcfg-后面跟的就是网卡的名称，可以通过双TAB键查看然后编辑，也可以使用ifconfig查看，也可以使用命令： vim /etc/sysconfig/network-scripts/ifcfg-* 编辑配置文件(没有安装vim可以使用Linux默认的vi编辑) 1vim /etc/sysconfig/network-scripts/ifcfg-ens33 比如这里就是ifcfg-ens33这个文件，现在使用： vim /etc/sysconfig/network-scripts/ifcfg-ens33 打开配置文件进行编辑，默认情况是dhcp动态获取的，如下图：这时候如果想修改成静态的，首先把BOOTPROTO=”dhcp”改成BOOTPROTO=”static”表示静态获取，ONBOOT=no改成ONBOOT=yes联网，然后在最后追加比如下面的配置： 1234BROADCAST=192.168.11.255IPADDR=192.168.11.128NETMASK=255.255.255.0GATEWAY=192.168.11.2 BROADCAST设置的是局域网广播地址，IPADDR就是静态IP，NETMASK是子网掩码，GATEWAY（注意事项在下面）就是网关或者路由地址；需要说明，原来还有个NETWORK配置的是局域网网络号，这个是ifcalc自动计算的，所以这里配置这些就足够了，最终配置如下图： 需要注意的是GATEWAY是需要与虚拟机设置的一致，否则ping不通外网，比如我的是192.168.11.2。如图：配置完成之后保存退出，设置完毕，然后使用命令： /etc/init.d/network restart 或者 service network restart 重启网络服务，重启后如果路由配置了支持静态IP，那么linux就能获取到刚才配置的IP地址，这样静态IP就配置成功了 配置成功后，dns配置一般会消失，所以这时候就ping不通域名了，需要配置DNS，配置文件位置是：/etc/resolv.conf，里面的nameserver指定dns服务器地址，这个配置很简单就不详细说了，如下图： 1vim /etc/resolv.conf 保存后，dns配置是立即生效的，原因很简单，只要本地需要解析缓冲区没有的域名，都要读取一遍dns配置文件，所以这个配置是立即生效的，不用任何操作,到这里静态IP并访问外网就没问题了. 啊哈哈！！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>设置静态ip</tag>
        <tag>ping外网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring @Configuration的使用]]></title>
    <url>%2F2019%2Fspring-Configuration%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.1、@Configuration配置spring并启动spring容器@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的，作用为：配置spring容器(应用上下文) 1.2、@Configuration启动容器+@Bean注册Bean，@Bean下管理bean的生命周期@Bean标注在方法上(返回某个实例的方法)，等价于spring的xml配置文件中的，作用为：注册bean对象 注： (1)、@Bean注解在返回实例的方法上，如果未通过@Bean指定bean的名称，则默认与标注的方法名相同； (2)、@Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域； (3)、既然@Bean的作用是注册bean对象，那么完全可以使用@Component、@Controller、@Service、@Repository等注解注册bean，当然需要配置@ComponentScan注解进行自动扫描。 @Bean下管理bean的生命周期可以使用基于 Java 的配置来管理 bean 的生命周期。@Bean 支持两种属性，即 initMethod 和destroyMethod，这些属性可用于定义生命周期方法。在实例化 bean 或即将销毁它时，容器便可调用生命周期方法。生命周期方法也称为回调方法，因为它将由容器调用。 1.3、@Configuration启动容器+@Component注册Bean @Component注册Bean @ComponentScan扫描Bean]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>@Configuration</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Specification中一个条件用或者表示(criteriaBuilder.or)]]></title>
    <url>%2F2019%2FSpecification%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%9D%A1%E4%BB%B6%E7%94%A8%E6%88%96%E8%80%85%E8%A1%A8%E7%A4%BA-criteriaBuilder-or%2F</url>
    <content type="text"><![CDATA[123456789101112Specification spec = (root, criteriaQuery, criteriaBuilder) -&gt; &#123; List&lt;Predicate&gt; predicate = new ArrayList&lt;&gt;(); Predicate pred1 = criteriaBuilder.equal(root.get(&quot;bizId&quot;), user.getBizId()); Predicate pred2 = criteriaBuilder.equal(root.get(&quot;bizId&quot;), 0); predicate.add(criteriaBuilder.or(pred1, pred2)); Predicate[] pre = new Predicate[predicate.size()]; criteriaQuery.where(predicate.toArray(pre)); return null;&#125;;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Specification</tag>
        <tag>criteriaBuilder.or</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java + Selenium + WebDriver自动版本化]]></title>
    <url>%2F2019%2FJava-Selenium-WebDriver%E8%87%AA%E5%8A%A8%E7%89%88%E6%9C%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344package packageOne;import org.openqa.selenium.By;import org.openqa.selenium.WebDriver;import org.openqa.selenium.chrome.ChromeDriver;public class OpenBaidu &#123; public static void main(String args[]) throws InterruptedException &#123; // 指定谷歌驱动的地址(找到对应的驱动) System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;D:/chromedriver.exe&quot;); // 实例化一个WebDriver的对象，此时会启动谷歌浏览器 WebDriver driver = new ChromeDriver(); // 最大化浏览器窗口 driver.manage().window().maximize(); // 打开百度首页 driver.get(&quot;https://www.baidu.com/&quot;); // 在搜索框中输入查询内容：自动化测试 driver.findElement(By.id(&quot;kw&quot;)).sendKeys(&quot;自动化测试&quot;); // 强制等待3秒 Thread.sleep(3000); // 点击“百度一下” 执行搜索 driver.findElement(By.id(&quot;su&quot;)).click(); // 强制等待3秒 Thread.sleep(4000); try &#123; // 关闭谷歌浏览器 driver.quit(); System.out.println(&quot;浏览器已关闭&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;浏览器关闭失败&quot;); &#125; &#125;&#125; 具体请看：https://blog.csdn.net/yoyocat915/article/details/80269901]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Selenium</tag>
        <tag>自动版本化</tag>
        <tag>WebDriver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery: 点击button弹出新窗口]]></title>
    <url>%2F2019%2FjQuery-button%E5%AE%9E%E7%8E%B0target%E4%B8%BA-blank-%E7%82%B9%E5%87%BBbutton%E5%BC%B9%E5%87%BA%E6%96%B0%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[该方法可适用于跳转下载等 1234&lt;button id=&quot;clickGo&quot;&gt;跳转页面&lt;/button&gt;$(&quot;#clickGo&quot;).click(function () &#123; window.open(&apos;url&apos;, &apos;_blank&apos;)&#125;);]]></content>
      <categories>
        <category>html&amp;css&amp;js</category>
      </categories>
      <tags>
        <tag>点击button弹出新窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java导出 Excel，PDF]]></title>
    <url>%2F2019%2FExcel%E5%AF%BC%E5%87%BA-PDF%E5%AF%BC%E5%87%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[自我总结：结构可能比较复杂，不过涵盖知识点多 PDF导出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322import com.alibaba.fastjson.JSONObject;import com.itextpdf.text.*;import com.itextpdf.text.pdf.BaseFont;import com.itextpdf.text.pdf.PdfPCell;import com.itextpdf.text.pdf.PdfPTable;import com.itextpdf.text.pdf.PdfWriter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;import java.net.URLEncoder;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Set;@RestControllerpublic class InspectRecordPdfController extends BaseController &#123; @Autowired InspectRecordService inspectRecordService; @RequestMapping(value = &quot;/url/pdf/&#123;id&#125;&quot;, method = &#123;RequestMethod.GET&#125;) @ResponseBody public void pdfExport(@PathVariable(&quot;id&quot;) Long id, HttpServletResponse response) &#123; RespDto&lt;InspectRecord&gt; respDto = inspectRecordService.get(id); if (respDto.getSuccess()) &#123; InspectRecord record = respDto.getData(); try &#123; covertPdf(record, response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void covertPdf(InspectRecord record, HttpServletResponse response) throws IOException, DocumentException &#123; // 第一步，实例化一个document对象 Document document = new Document(); String filename = record.getName() + &quot;.pdf&quot;; // 清空response，否则可能会对程序有影响，因为在此之前有可能也用到了response，若不reset，后面的setCntentoType()有可能失效 response.reset(); response.setContentType(&quot;application/pdf&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(filename, &quot;utf-8&quot;)); // 第二步，设置要到出的路径 // 如果是浏览器通过request请求需要在浏览器中输出则使用下面方式 OutputStream out = response.getOutputStream(); // 第三步,设置字符,宋体 BaseFont bfChinese = BaseFont.createFont(&quot;STSong-Light&quot;, &quot;UniGB-UCS2-H&quot;, BaseFont.NOT_EMBEDDED); Font fontZH = new Font(bfChinese, 12.0F, Font.NORMAL); // 第四步，将pdf文件输出到磁盘 PdfWriter.getInstance(document, out); // 第五步，打开生成的pdf文件 document.open(); Font greenFont = new Font(bfChinese); greenFont.setColor(BaseColor.GREEN); Font redFont = new Font(bfChinese); redFont.setColor(BaseColor.RED); Font orangeFont = new Font(bfChinese); orangeFont.setColor(BaseColor.ORANGE); String title = &quot;巡检信息&quot;; Paragraph paragraph = new Paragraph(); paragraph.setAlignment(Element.ALIGN_CENTER); paragraph.add(new Chunk(title, fontZH).setLocalDestination(title)); // paragraph.add(new Chunk(title, new Font(bfChinese, 20F, Font.BOLD)).setLocalDestination(title)); document.add(paragraph); document.add(new Paragraph(&quot;\n&quot;)); PdfPTable table = new PdfPTable(2); table.setHorizontalAlignment(Element.ALIGN_CENTER); float[] widths = &#123;20f, 90f&#125;; table.setWidths(widths); PdfPCell cell; cell = new PdfPCell(new Paragraph(&quot;巡检名称&quot;, fontZH)); setAndAddCellStyle(table, cell); cell = new PdfPCell(new Paragraph(record.getName(), fontZH)); setAndAddCellStyle(table, cell); cell = new PdfPCell(new Paragraph(&quot;巡检类型&quot;, fontZH)); setAndAddCellStyle(table, cell); Integer recordType = record.getType(); String typeText = &quot;-&quot;; if (recordType == 0) &#123; typeText = &quot;快速巡检-脚本&quot;; &#125; else if (recordType == 1) &#123; typeText = &quot;常规巡检&quot;; &#125; else if (recordType == 2) &#123; typeText = &quot;定时巡检&quot;; &#125; cell = new PdfPCell(new Paragraph(typeText, fontZH)); setAndAddCellStyle(table, cell); cell = new PdfPCell(new Paragraph(&quot;执行人员&quot;, fontZH)); setAndAddCellStyle(table, cell); cell = new PdfPCell(new Paragraph(record.getUserName(), fontZH)); setAndAddCellStyle(table, cell); cell = new PdfPCell(new Paragraph(&quot;巡检状态&quot;, fontZH)); setAndAddCellStyle(table, cell); Integer recordStatus = record.getStatus(); if (recordStatus == 0) &#123; cell = new PdfPCell(new Paragraph(&quot;启动中&quot;, fontZH)); &#125; else if (recordStatus == 1) &#123; cell = new PdfPCell(new Paragraph(&quot;执行中&quot;, fontZH)); &#125; else if (recordStatus == 2) &#123; cell = new PdfPCell(new Paragraph(&quot;成功&quot;, greenFont)); &#125; else if (recordStatus == 3) &#123; cell = new PdfPCell(new Paragraph(&quot;错误&quot;, redFont)); &#125; else &#123; cell = new PdfPCell(new Paragraph(&quot;-&quot;, fontZH)); &#125; setAndAddCellStyle(table, cell); cell = new PdfPCell(new Paragraph(&quot;告警状态&quot;, fontZH)); setAndAddCellStyle(table, cell); Boolean recordWarning = record.getWarning(); if (!recordWarning) &#123; cell = new PdfPCell(new Paragraph(&quot;正常&quot;, greenFont)); &#125; else &#123; cell = new PdfPCell(new Paragraph(&quot;告警&quot;, orangeFont)); &#125; setAndAddCellStyle(table, cell); cell = new PdfPCell(new Paragraph(&quot;创建时间&quot;, fontZH)); setAndAddCellStyle(table, cell); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String createTime = simpleDateFormat.format(record.getCreateTime()); cell = new PdfPCell(new Paragraph(createTime, fontZH)); setAndAddCellStyle(table, cell); cell = new PdfPCell(new Paragraph(&quot;执行时长&quot;, fontZH)); setAndAddCellStyle(table, cell); Double totalTime = record.getTotalTime(); if (totalTime != null) &#123; cell = new PdfPCell(new Paragraph(totalTime.toString() + &quot; 秒&quot;, fontZH)); &#125; else &#123; cell = new PdfPCell(new Paragraph(&quot;-&quot;, fontZH)); &#125; setAndAddCellStyle(table, cell); // 告警开始 List&lt;InspectRecordWarning&gt; warnList = record.getInspectRecordWarnings(); if (warnList.size() &gt; 0) &#123; cell = new PdfPCell(new Paragraph(&quot;告警信息&quot;, fontZH)); setAndAddCellStyle(table, cell); PdfPTable warnTable = new PdfPTable(3); warnTable.setWidths(new float[]&#123;22f, 23f, 55f&#125;); setAndAddCellStyle(table, new PdfPCell(getWarningInfo(warnList, warnTable, fontZH))); &#125; List&lt;InspectRecordItem&gt; list = record.getInspectRecordItems(); List&lt;Object&gt; objects = new ArrayList&lt;&gt;(); for (Object item : list) &#123; objects.add(item); objects.removeAll(Collections.singleton(null)); &#125; if (objects.size() &gt; 0) &#123; cell = new PdfPCell(new Paragraph(&quot;执行错误&quot;, fontZH)); setAndAddCellStyle(table, cell); PdfPTable errorTable = new PdfPTable(3); errorTable.setWidths(new float[]&#123;22f, 23f, 55f&#125;); setAndAddCellStyle(table, new PdfPCell(getErrorInfo(list, errorTable, fontZH))); &#125; cell = new PdfPCell(new Paragraph(&quot;执行详情&quot;, fontZH)); setAndAddCellStyle(table, cell); PdfPTable detailTable = new PdfPTable(3); detailTable.setWidths(new float[]&#123;22f, 23f, 55f&#125;); setAndAddCellStyle(table, new PdfPCell(getDetailInfo(list, detailTable, fontZH))); // 添加大表格 document.add(table); // 第七步，关闭document document.close(); System.out.println(&quot;导出pdf成功~&quot;); &#125; private PdfPTable getWarningInfo(List&lt;InspectRecordWarning&gt; list, PdfPTable warningTable, Font fontZH) &#123; PdfPCell cell; cell = new PdfPCell(new Paragraph(&quot;主机ip&quot;, fontZH)); setCellCenter(cell); warningTable.addCell(cell); cell = new PdfPCell(new Paragraph(&quot;指标项&quot;, fontZH)); setCellCenter(cell); cell = new PdfPCell(new Paragraph(&quot;告警信息&quot;, fontZH)); setCellCenter(cell); warningTable.addCell(cell); for (InspectRecordWarning item : list) &#123; cell = new PdfPCell(new Paragraph(item.getIp(), fontZH)); setCellCenter(cell); warningTable.addCell(cell); cell = new PdfPCell(new Paragraph(item.getInspectItemName(), fontZH)); setCellCenter(cell); warningTable.addCell(cell); String content = item.getContent(); cell = new PdfPCell(new Paragraph(content != null ? content : &quot;-&quot;, fontZH)); setCellCenter(cell); warningTable.addCell(cell); &#125; return warningTable; &#125; /* 获取执行错误信息 */ private PdfPTable getErrorInfo(List&lt;InspectRecordItem&gt; list, PdfPTable errorTable, Font fontZH) &#123; PdfPCell cell; cell = new PdfPCell(new Paragraph(&quot;主机ip&quot;, fontZH)); setCellCenter(cell); errorTable.addCell(cell); cell = new PdfPCell(new Paragraph(&quot;指标项&quot;, fontZH)); setCellCenter(cell); errorTable.addCell(cell); cell = new PdfPCell(new Paragraph(&quot;执行错误信息&quot;, fontZH)); setCellCenter(cell); errorTable.addCell(cell); for (InspectRecordItem item : list) &#123; cell = new PdfPCell(new Paragraph(item.getIp(), fontZH)); setCellCenter(cell); errorTable.addCell(cell); cell = new PdfPCell(new Paragraph(item.getInspectItemName(), fontZH)); setCellCenter(cell); errorTable.addCell(cell); String errorInfo = item.getScriptErrorInfo(); cell = new PdfPCell(new Paragraph(errorInfo !=null ? errorInfo : &quot;-&quot;, fontZH)); setCellCenter(cell); errorTable.addCell(cell); &#125; return errorTable; &#125; private PdfPTable getDetailInfo(List&lt;InspectRecordItem&gt; list, PdfPTable detailTable, Font fontZH) &#123; PdfPCell cell; cell = new PdfPCell(new Paragraph(&quot;主机ip&quot;, fontZH)); setCellCenter(cell); detailTable.addCell(cell); cell = new PdfPCell(new Paragraph(&quot;指标项&quot;, fontZH)); setCellCenter(cell); detailTable.addCell(cell); cell = new PdfPCell(new Paragraph(&quot;详情&quot;, fontZH)); setCellCenter(cell); detailTable.addCell(cell); for (InspectRecordItem item : list) &#123; cell = new PdfPCell(new Paragraph(item.getIp(), fontZH)); setCellCenter(cell); detailTable.addCell(cell); cell = new PdfPCell(new Paragraph(item.getInspectItemName(), fontZH)); setCellCenter(cell); detailTable.addCell(cell); // 详情 String log = item.getLog(); if (log != null) &#123; JSONObject logJsonObj = JSONObject.parseObject(log); Set&lt;String&gt; logSet = logJsonObj.keySet(); Object logObj; String logStr = &quot;&quot;; for (String key : logSet) &#123; logObj = logJsonObj.get(key); logStr += key + &quot; : &quot; + logObj.toString() + &quot;\n&quot;; &#125; cell = new PdfPCell(new Paragraph(&quot;&quot;.equals(logStr) ? &quot;-&quot; : logStr, fontZH)); &#125; else &#123; cell = new PdfPCell(new Paragraph(&quot;-&quot;, fontZH)); &#125; setCellCenter(cell); detailTable.addCell(cell); &#125; return detailTable; &#125; private void setAndAddCellStyle(PdfPTable table, PdfPCell cell) &#123; cell.setMinimumHeight(30.0F); cell.setPaddingTop(10f); cell.setPaddingBottom(10f); setCellCenter(cell); cell.setBorder(Rectangle.NO_BORDER); table.addCell(cell); &#125; private void setCellCenter(PdfPCell cell) &#123; cell.setHorizontalAlignment(Element.ALIGN_CENTER); cell.setVerticalAlignment(Element.ALIGN_MIDDLE); &#125;&#125; Excel导出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341import com.alibaba.fastjson.JSONObject;import org.apache.poi.hssf.usermodel.*;import org.apache.poi.hssf.util.HSSFColor;import org.apache.poi.ss.usermodel.HorizontalAlignment;import org.apache.poi.ss.usermodel.VerticalAlignment;import org.apache.poi.ss.util.CellRangeAddress;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletResponse;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.net.URLEncoder;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Set;@RestControllerpublic class InspectRecordExcelController extends BaseController &#123; @Autowired InspectRecordService inspectRecordService; public static final short BOLD_FONT = 20; public static final short NORMAL_FONT = 12; // 创建表头 @RequestMapping(value = &quot;/inspect/record/excel/&#123;id&#125;&quot;, method = &#123;RequestMethod.GET&#125;) @ResponseBody public void createTitle(@PathVariable(&quot;id&quot;) Long id, HttpServletResponse response) throws IOException &#123; HSSFWorkbook workbook = new HSSFWorkbook(); HSSFSheet sheet = workbook.createSheet(); sheet.setColumnWidth(0, 16 * 256); sheet.setColumnWidth(1, 20 * 256); sheet.setColumnWidth(2, 30 * 256); sheet.setColumnWidth(3, 40 * 256); InspectRecord record = inspectRecordService.get(id).getData(); sheet.addMergedRegion(new CellRangeAddress(0, 1, 0, 3)); for (int i = 2; i &lt; 9; i++) &#123; sheet.addMergedRegion(new CellRangeAddress(i, i, 1, 3)); &#125; HSSFRow row = sheet.createRow(0); HSSFCell cell = row.createCell(0); cell.setCellStyle(getStyle(workbook, BOLD_FONT, true)); cell.setCellValue(&quot;巡检信息&quot;); HSSFRow row2 = sheet.createRow(2); HSSFCell cell2 = row2.createCell(0); cell2.setCellValue(&quot;巡检名称&quot;); cell2.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell2 = row2.createCell(1); cell2.setCellValue(record.getName()); cell2.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); HSSFRow row3 = sheet.createRow(3); HSSFCell cell3 = row3.createCell(0); cell3.setCellValue(&quot;巡检类型&quot;); cell3.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell3 = row3.createCell(1); Integer recordType = record.getType(); if (recordType == 0) &#123; cell3.setCellValue(&quot;快速巡检-脚本&quot;); &#125; else if (recordType == 1) &#123; cell3.setCellValue(&quot;常规巡检&quot;); &#125; else if (recordType == 2) &#123; cell3.setCellValue(&quot;定时巡检&quot;); &#125; else &#123; cell3.setCellValue(&quot;-&quot;); &#125; cell3.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); HSSFRow row4 = sheet.createRow(4); HSSFCell cell4 = row4.createCell(0); cell4.setCellValue(&quot;用户名&quot;); cell4.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell4 = row4.createCell(1); cell4.setCellValue(record.getUserName()); cell4.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); HSSFRow row5 = sheet.createRow(5); HSSFCell cell5 = row5.createCell(0); cell5.setCellValue(&quot;巡检状态&quot;); cell5.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell5 = row5.createCell(1); Integer status = record.getStatus(); if (status == 0) &#123; cell5.setCellValue(&quot;启动中&quot;); cell5.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); &#125; else if (status == 1) &#123; cell5.setCellValue(&quot;执行中&quot;); cell5.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); &#125; else if (status == 2) &#123; setStatus(workbook, cell5, &quot;成功&quot;, HSSFColor.GREEN.index); &#125; else if (status == 3) &#123; setStatus(workbook, cell5, &quot;错误&quot;, HSSFColor.RED.index); &#125; else &#123; cell5.setCellValue(&quot;-&quot;); cell5.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); &#125; HSSFRow row6 = sheet.createRow(6); HSSFCell cell6 = row6.createCell(0); cell6.setCellValue(&quot;告警状态&quot;); cell6.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell6 = row6.createCell(1); if (!record.getWarning()) &#123; setStatus(workbook, cell6, &quot;正常&quot;, HSSFColor.GREEN.index); &#125; else &#123; setStatus(workbook, cell6, &quot;告警&quot;, HSSFColor.ORANGE.index); &#125; HSSFRow row7 = sheet.createRow(7); HSSFCell cell7 = row7.createCell(0); cell7.setCellValue(&quot;创建时间&quot;); cell7.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell7 = row7.createCell(1); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); cell7.setCellValue(sdf.format(record.getCreateTime())); cell7.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); HSSFRow row8 = sheet.createRow(8); HSSFCell cell8 = row8.createCell(0); cell8.setCellValue(&quot;执行时长&quot;); cell8.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell8 = row8.createCell(1); Double totalTime = record.getTotalTime(); if (totalTime != null) &#123; cell8.setCellValue(totalTime + &quot;秒&quot;); &#125; else &#123; cell8.setCellValue(&quot;-&quot;); &#125; cell8.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); // 嵌套 List&lt;InspectRecordWarning&gt; warnings = record.getInspectRecordWarnings(); int warnSize = warnings.size(); if (warnSize &gt; 0) &#123; // 如果有告警信息才显示对象 sheet.addMergedRegion(new CellRangeAddress(10, 10 + warnSize, 0, 0)); HSSFRow row10 = sheet.createRow(10); HSSFCell cell10 = row10.createCell(0); cell10.setCellValue(&quot;告警信息&quot;); cell10.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell10 = row10.createCell(1); cell10.setCellValue(&quot;主机ip&quot;); cell10.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell10 = row10.createCell(2); cell10.setCellValue(&quot;指标项&quot;); cell10.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell10 = row10.createCell(3); cell10.setCellValue(&quot;告警信息&quot;); cell10.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); for (int i = 0; i &lt; warnSize;) &#123; InspectRecordWarning warning = warnings.get(i); i += 1; HSSFRow row11 = sheet.createRow(10 + i); HSSFCell cell11 = row11.createCell(1); cell11.setCellValue(warning.getIp()); cell11.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); cell11 = row11.createCell(2); cell11.setCellValue(warning.getInspectItemName()); cell11.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); cell11 = row11.createCell(3); String warnInfo = warning.getContent(); cell11.setCellValue(warnInfo == null ? &quot;-&quot; : warnInfo); cell11.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); &#125; &#125; // 错误开始 List&lt;InspectRecordItem&gt; list = record.getInspectRecordItems(); int listSize = list.size(); List&lt;Object&gt; objects = new ArrayList&lt;&gt;(); for (InspectRecordItem item : list) &#123; objects.add(item); objects.removeAll(Collections.singleton(null)); &#125; int errorSize = objects.size(); if (objects.size() &gt; 0) &#123; // 如果有错误信息才展示列表 sheet.addMergedRegion(new CellRangeAddress(11 + warnSize, 11 + warnSize + errorSize, 0, 0)); HSSFRow row12 = sheet.createRow(11 + warnSize); HSSFCell cell12 = row12.createCell(0); cell12.setCellValue(&quot;错误信息&quot;); cell12.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell12 = row12.createCell(1); cell12.setCellValue(&quot;主机ip&quot;); cell12.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell12 = row12.createCell(2); cell12.setCellValue(&quot;指标项&quot;); cell12.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell12 = row12.createCell(3); cell12.setCellValue(&quot;错误信息&quot;); cell12.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); for (int i = 0; i &lt; listSize; ) &#123; InspectRecordItem item = list.get(i); i += 1; HSSFRow row13 = sheet.createRow(11 + i + warnSize); HSSFCell cell13 = row13.createCell(1); cell13.setCellValue(item.getIp()); cell13.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); cell13 = row13.createCell(2); cell13.setCellValue(item.getInspectItemName()); cell13.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); cell13 = row13.createCell(3); String errorInfo = item.getScriptErrorInfo(); cell13.setCellValue(errorInfo == null ? &quot;-&quot; : errorInfo); cell13.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); &#125; &#125; // 详情必须显示 sheet.addMergedRegion(new CellRangeAddress(12 + warnSize + errorSize, 12 + warnSize + errorSize + listSize, 0, 0)); HSSFRow row13 = sheet.createRow(12 + warnSize + errorSize); HSSFCell cell14 = row13.createCell(0); cell14.setCellValue(&quot;详细信息&quot;); cell14.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell14 = row13.createCell(1); cell14.setCellValue(&quot;主机ip&quot;); cell14.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell14 = row13.createCell(2); cell14.setCellValue(&quot;指标项&quot;); cell14.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); cell14 = row13.createCell(3); cell14.setCellValue(&quot;详细信息&quot;); cell14.setCellStyle(getStyle(workbook, NORMAL_FONT, true)); for (int i = 0; i &lt; listSize;) &#123; InspectRecordItem item = list.get(i); i += 1; HSSFRow row14 = sheet.createRow(12 + i + warnSize + errorSize); HSSFCell cell15 = row14.createCell(1); cell15.setCellValue(item.getIp()); cell15.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); cell15 = row14.createCell(2); cell15.setCellValue(item.getInspectItemName()); cell15.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); cell15 = row14.createCell(3); String log = item.getLog(); if (log != null) &#123; JSONObject logJsonObj = JSONObject.parseObject(log); Set&lt;String&gt; logSet = logJsonObj.keySet(); Object logObj; String logStr = &quot;&quot;; for (String key : logSet) &#123; logObj = logJsonObj.get(key); logStr += key + &quot;：&quot; + logObj.toString() + &quot;\n&quot;; &#125; cell15.setCellValue(&quot;&quot;.equals(logStr) ? &quot;-&quot; : logStr); &#125; else &#123; cell15.setCellValue(&quot;-&quot;); &#125; cell15.setCellStyle(getStyle(workbook, NORMAL_FONT, false)); &#125; String filename = record.getName() + &quot;.xls&quot;; buildExcelDocument(filename, workbook, response); &#125; /** * @param cellValue 单元格填充值 * @param workbook 工作表 * @param cell 单元格 * @param colorIndex 单元格字体颜色 */ private void setStatus(HSSFWorkbook workbook, HSSFCell cell, String cellValue, short colorIndex) &#123; cell.setCellValue(cellValue); HSSFFont font = workbook.createFont(); font.setColor(colorIndex); HSSFCellStyle style = getStyle(workbook, NORMAL_FONT, false); style.setFont(font); cell.setCellStyle(style); &#125; /** * 标题或者第一列数据信息单元格样式 * * @param fontHeight 标题20， 第一列12，第二列12 */ private HSSFCellStyle getStyle(HSSFWorkbook workbook, short fontHeight, boolean isBold) &#123; HSSFFont font = workbook.createFont(); font.setFontHeightInPoints((fontHeight)); font.setBold(isBold); font.setFontName(&quot;宋体&quot;); HSSFCellStyle style = workbook.createCellStyle(); style.setFont(font); style.setWrapText(true); style.setAlignment(HorizontalAlignment.CENTER); style.setVerticalAlignment(VerticalAlignment.CENTER); return style; &#125; // 浏览器下载excel private void buildExcelDocument(String filename, HSSFWorkbook workbook, HttpServletResponse response) throws IOException &#123; // 清空response，否则可能会对程序有影响，因为在此之前有可能也用到了response，若不reset，后面的setCntentoType()有可能失效 response.reset(); response.setContentType(&quot;application/vnd.ms-excel&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(filename, &quot;utf-8&quot;)); OutputStream os = response.getOutputStream(); workbook.write(os); os.flush(); os.close(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java两种发送邮件的方式]]></title>
    <url>%2F2019%2FUntitled%2F</url>
    <content type="text"><![CDATA[Java两种发送邮件的方式(不止这两种)：pom： 12345&lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.5&lt;/version&gt;&lt;/dependency&gt; 1. Javamail 发送163邮件 原文：https://blog.csdn.net/qq_18573005/article/details/79805507#commentBox 2. Java通过QQ邮箱发送邮件：需要用户名密码验证邮件发送实例:你需要在登录QQ邮箱后台在”设置”=》账号中开启POP3/SMTP服务 ，如下图所示：QQ 邮箱通过生成授权码来设置密码：Java 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 需要用户名密码邮件发送，你需要在qq后台设置import java.util.Properties;import javax.mail.Authenticator;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.PasswordAuthentication;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage; public class QQSendEmail &#123; public static void main(String [] args) &#123; // 收件人电子邮箱 String to = &quot;xxx@qq.com&quot;; // 发件人电子邮箱 String from = &quot;xxx@qq.com&quot;; // 指定发送邮件的主机为 smtp.qq.com String host = &quot;smtp.qq.com&quot;; //QQ 邮件服务器 // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(&quot;mail.smtp.host&quot;, host); properties.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;); // 获取默认session对象 Session session = Session.getDefaultInstance(properties,new Authenticator()&#123; public PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication(&quot;xxx@qq.com&quot;, &quot;填写qq邮箱授权码&quot;); //发件人邮件用户名、授权码 &#125; &#125;); try&#123; // 创建默认的 MimeMessage 对象 MimeMessage message = new MimeMessage(session); // Set From: 头部头字段 message.setFrom(new InternetAddress(from)); // Set To: 头部头字段 message.addRecipient(Message.RecipientType.TO, new InternetAddress(to)); // Set Subject: 头部头字段 message.setSubject(&quot;This is the Subject Line!&quot;); // 设置消息体 message.setText(&quot;This is actual message&quot;); // 发送消息 Transport.send(message); System.out.println(&quot;Sent message successfully....from runoob.com&quot;); &#125;catch (MessagingException mex) &#123; mex.printStackTrace(); &#125; &#125;&#125; 原文：https://www.runoob.com/java/java-sending-email.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java发送邮件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mix Note]]></title>
    <url>%2F2019%2FMix-Note%2F</url>
    <content type="text"><![CDATA[Mysql： Java MySQL 连接：https://www.runoob.com/java/java-mysql-connect.html设置mysql自增起始数：alter table 表名 AUTO_INCREMENT=起始数字; Docker：再删除镜像之前需要先删除container（docker rm id，docker rmi image） int和char可以互串 tomcat的安装目录是tomcat的软件存放的目录，根目录是项目存放的目录。 位于运算（n |= n &gt;&gt;&gt; 8） https://www.cnblogs.com/qubaba/p/11558127.html https://zhidao.baidu.com/question/291266003.html python第三方库地址： https://pypi.python.org/simple 默认地址国外地址 https://pypi.tuna.tsinghua.edu.cn/simple/ 清华大学镜像 http://pypi.douban.com/simple/ 豆瓣镜像 http://mirrors.aliyun.com/pypi/simple/ 阿里镜像]]></content>
      <categories>
        <category>Mixed</category>
      </categories>
      <tags>
        <tag>mixed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在高德地图使用: AMap is not defined]]></title>
    <url>%2F2019%2F%E5%9C%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E4%BD%BF%E7%94%A8-AMap-is-not-defined%2F</url>
    <content type="text"><![CDATA[高德模板原版引入： 1&lt;script language=&quot;javascript&quot; src=&quot;//webapi.amap.com/maps?v=1.4.15&amp;key=43b2dae85b7a78ed9ff10f40427c1d8b&amp;plugin=AMap.ControlBar&quot;&gt;&lt;/script&gt; 当时这是个坑，因为src里没有加上http:或https:，应为： 1&lt;script language=&quot;javascript&quot; src=&quot;https://webapi.amap.com/maps?v=1.4.15&amp;key=43b2dae85b7a78ed9ff10f40427c1d8b&amp;plugin=AMap.ControlBar&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>html&amp;css&amp;js</category>
      </categories>
      <tags>
        <tag>高德地图: AMap is not defined</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取整取余问题]]></title>
    <url>%2F2019%2F%E5%8F%96%E6%95%B4%E5%8F%96%E4%BD%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[i对j取余问题，一般这种常用于循环问题举出几个例子，你应该就懂了。 公式：a÷b=c……d则a/b=c,a%b=d 例子例如：35除以3，商11，余数2。 正常情况下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取整情况下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取余情况下：35 ÷ 3 = 11…2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35/3=11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35%3=2 当i小于j呢？例如：16除以35，商0，余数16。 16 ÷ 35 = 0……16同理可得取整的值和取余的值。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>取整取余</tag>
        <tag>i % j 循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转换模型时,Django model_to_dict会跳过所有DateTimeField]]></title>
    <url>%2F2019%2F%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%9E%8B%E6%97%B6-Django-model-to-dict%E4%BC%9A%E8%B7%B3%E8%BF%87%E6%89%80%E6%9C%89DateTimeField%2F</url>
    <content type="text"><![CDATA[原文地址：http://www.voidcn.com/article/p-wgqimgrq-bug.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pycharm 2019.1中打开.md文件出现卡死的情况]]></title>
    <url>%2F2019%2FPycharm-2019-1%E4%B8%AD%E6%89%93%E5%BC%80-md%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0%E5%8D%A1%E6%AD%BB%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[尊重原创源地址：https://blog.csdn.net/qq_41897629/article/details/89163939]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于python manage.py makemigrations，python manage.py migrate不能建表]]></title>
    <url>%2F2019%2F%E5%85%B3%E4%BA%8Epython-manage-py-makemigrations%EF%BC%8Cpython-manage-py-migrate%E4%B8%8D%E8%83%BD%E5%BB%BA%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[尊重原创：https://www.jb51.net/article/140960.htm 如果你想要重新生成表，就直接删除数据库对应的表，然后执行 12python manage.py makemigrationspython manage.py migrate 有些人是会成功的，但是我总觉得一般情况下是不会成功的，所有，我们直接往下看-&gt; 一般情况下，在我们删除表和生成的0001_initial.py文件以后，执行: 12python manage.py makemigrationspython manage.py migrate 还是不能生成表,提示:No changes detected 最后一步：我们进入数据库，然后发现有一张django_migrations表,里面记录这有关创建表的记录,删除对应的数据表 （原文说删表，其实是把这条数据删掉）:命令：delete from django_migrations where app=&#39;yourappname&#39;; 然后再执行： 12python manage.py makemigrationspython manage.py migrate 成功重新创建表，hurray！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python manage.py makemigrations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dialog的使用方法]]></title>
    <url>%2F2019%2FDialog%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js弹框12345678910111213141516171819202122232425&lt;button id=&quot;tantantan&quot;&gt;带按钮弹窗&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; //带按钮弹窗 $(&quot;#tantantan&quot;).click(function() &#123; var d = dialog(&#123; let content_html =&quot;&quot;, width: 260, title: &apos;提示&apos;, content: content_html, okValue: &apos;确定&apos;, ok: function() &#123; // do something &#125;, cancelValue: &apos;取消&apos;, cancel: function() &#123; // do something &#125;, onshow: function() &#123; // do something &#125;, &#125;); d.show(); &#125;);&lt;/script&gt; Dialog showModal() 方法123456&lt;dialog id=&quot;myDialog&quot;&gt;这是一个对话窗口&lt;/dialog&gt;&lt;script&gt; function myFunction() &#123; document.getElementById(&quot;myDialog&quot;).showModal(); &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>html&amp;css&amp;js</category>
      </categories>
      <tags>
        <tag>Dialog的使用方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python ValueError: too many values to unpack]]></title>
    <url>%2F2019%2FValueError-too-many-values-to-unpack%2F</url>
    <content type="text"><![CDATA[错误代码: 1234def update_handle(request): _get = request.POST TaskDetailTwo.objects.get(_get[&quot;id&quot;]) 略略略 正确代码: 1234def update_handle(request): _get = request.POST TaskDetailTwo.objects.get(id=_get[&quot;id&quot;]) 略略略 这是因为该方法的条件中未写对应数据库的字段名，filter等方法等同。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ValueError: too many values to unpack</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于注解@Controller和@RestController返回页面]]></title>
    <url>%2F2019%2F%E5%85%B3%E4%BA%8E%E6%B3%A8%E8%A7%A3-Controller%E5%92%8C-RestController%E8%BF%94%E5%9B%9E%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[默认情况下，@Controller返回页面，@RestController返回数据。 但是在有些情况下需要在被@RestController的注解时返回页面的，我们就需要用到视图ModelAndView： 12345@RequestMapping(value=&quot;/tologin&quot;, method=RequestMethod.GET) public ModelAndView login()&#123; ModelAndView mv = new ModelAndView(&quot;index&quot;); return mv;&#125; 那如果要是在被@Controller注解下的方法返回数据呢？(我看你是爱吃鱼挑刺)： 12345678@RequestMapping(&quot;/goshopping&quot;, method=RequestMethod.POST)@ResponseBody // 其实就差个这个(鄙人觉得)public Map&lt;String, Object&gt; goshopping(Me me, Money money) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;me&quot;, &quot;me&quot;); map.put(&quot;money&quot;, money); return map;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>@Controller与@RestController</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker删除none镜像]]></title>
    <url>%2F2019%2Fdocker-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4none%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[原创地址：https://blog.51cto.com/13767724/2287193 如果执行Dockerfile文件报错会生成镜像none.删除none的镜像，要先删除镜像中的容器。要删除镜像中的容器，必须先停止容器 执行的命令：$ docker stop $(docker ps -a | grep “Exited” | awk ‘{print $1 }’) //停止容器$ docker rm $(docker ps -a | grep “Exited” | awk ‘{print $1 }’) //删除容器$ docker rmi $(docker images | grep “none” | awk ‘{print $3}’) //删除镜像]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker删除none镜像 </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux java编译报错找不到或无法加载主类]]></title>
    <url>%2F2019%2FLinux-java%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%E6%89%BE%E4%B8%8D%E5%88%B0%E6%88%96%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[编译运行有两个步骤：javac LinuxJava.java(不报错)java LinuxJava(报错) 我发现的问题是我再复制的时候将该文件头部的包名路径带上了，去掉在运行就不报错了。 错误例子： 12345678package com.example.canvas;public class LinuxDemo &#123; public static void main(String[] args) &#123; System.out.println(&quot;===============&quot;); &#125;&#125; 纠正例子： 123456public class LinuxDemo &#123; public static void main(String[] args) &#123; System.out.println(&quot;===============&quot;); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Linux java编译报错找不到或无法加载主类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读取文件内容]]></title>
    <url>%2F2019%2Fjava%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122File files = new File(String pathname); // 例如：&quot;C:\\Users\\用户名\\Desktop\\a.sql&quot;BufferedReader reader = null;StringBuffer sbf = new StringBuffer();try &#123; reader = new BufferedReader(new FileReader(files)); String tempStr; while ((tempStr = reader.readLine()) != null) &#123; sbf.append(tempStr); &#125; reader.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125;&#125;System.out.println(&quot;=========\n&quot; + sbf); //sbf就是文件的内容]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java读取文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对ganymed-ssh2的使用]]></title>
    <url>%2F2019%2FJava%E5%AF%B9ganymed-ssh2%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package com.utils;import ch.ethz.ssh2.Connection;import ch.ethz.ssh2.Session;import ch.ethz.ssh2.StreamGobbler;import com.bocloud.common.model.BocloudResult;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.ConnectException;/** * @author jiao * @since 2019/9/20 16:06 */public class GanymedUtil &#123; private static Connection login(String ip, int port, String username, String password) &#123; boolean flag; Connection connection = null; try &#123; connection = new Connection(ip, port); connection.connect();// 连接 flag = connection.authenticateWithPassword(username, password);// 认证 if (flag) &#123; System.out.println(&quot;================登录成功==================&quot;); return connection; &#125; &#125; catch (IOException e) &#123; System.out.println(&quot;登录失败,请检查IP或端口是否有误：&quot; + e); connection.close(); System.exit(-1); &#125; return connection; &#125; /** * 远程执行shell脚本或者命令 * * @param command 即将执行的命令 * @return 命令执行完后返回的结果值 */ private static String execCommand(Connection connection, String command) &#123; String result = &quot;&quot;; try &#123; if (connection != null) &#123; Session session = null;// 打开一个会话 try &#123; session = connection.openSession(); &#125; catch (IllegalStateException ise) &#123; System.out.println(&quot;请检查用户名或密码是否有误&quot;); ise.printStackTrace(); System.exit(-1); &#125; try &#123; session.execCommand(command);// 执行命令 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String DEFAULT_CHART = &quot;UTF-8&quot;; result = processStdout(session.getStdout(), DEFAULT_CHART); if (&quot;&quot;.equals(result)) &#123; System.out.println(&quot;请检查脚本内容是否有误&quot;); System.exit(1); &#125; connection.close(); session.close(); &#125; &#125; catch (IOException e) &#123; System.out.println(&quot;执行命令失败,链接conn:&quot; + connection + &quot;,执行的命令：&quot; + command + &quot; &quot; + e); e.printStackTrace(); &#125; return result; &#125; /** * 解析脚本执行返回的结果集 * * @param in 输入流对象 * @param charset 编码 * @return 以纯文本的格式返回 */ private static String processStdout(InputStream in, String charset) &#123; InputStream stdout = new StreamGobbler(in); StringBuilder buffer = new StringBuilder(); try &#123; BufferedReader br = new BufferedReader(new InputStreamReader(stdout, charset)); String line; while ((line = br.readLine()) != null) &#123; buffer.append(line).append(&quot;\n&quot;); &#125; br.close(); &#125; catch (IOException e) &#123; System.out.println(&quot;解析脚本出错：&quot; + e.getMessage()); e.printStackTrace(); &#125; return buffer.toString(); &#125; public static BocloudResult ganymedExecCommand(String host, int port, String username, String password, String command) &#123; Connection connection = login(host, port, username, password); String execCommand = execCommand(connection, command); if (execCommand.contains(&quot;successfully&quot;)) &#123; return new BocloudResult(true, &quot;安装成功&quot;); &#125; else &#123; return new BocloudResult(false, &quot;安装失败&quot;); &#125; &#125; public static void main(String[] args) &#123; String ip = &quot;192.168.112.130&quot;; String username = &quot;root&quot;; String password = &quot;root&quot;; int port = 22; /*String url = &quot;ls /;&quot;;*/ String url = &quot;https://github.com/jiaoht/LinuxUse/raw/master/CatDisk&quot;; String getArgsExecScript = &quot; wget -c &quot; + install_url + &quot; -O installer; sh installer;\n&quot;; String rmInstaller = &quot; rm -rf installer;\n&quot;; String getAndRm = getArgsExecScript + rmInstaller; String command = &quot;cd /tmp;\n&quot; + &quot;if [ ! -f &apos;installer&apos; ];then\n&quot; + getAndRm + &quot;else\n&quot; + rmInstaller + getAndRm + &quot;fi&quot;; System.out.println(ganymedExecCommand(ip, port, username, password, command)); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ganymed-ssh2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx搭建文件服务器(指定目录)]]></title>
    <url>%2F2019%2Fginx%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8-%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[通过yum install -y nginx安装，配置文件是/etc/nginx/nginx.conf。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server &#123; listen 8055 default_server; listen [::]:8055 default_server; server_name _; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; root /usr/share/nginx/html/download; autoindex on; #开启索引功能 autoindex_exact_size off; #关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb） autoindex_localtime on; #显示本机时间而非 GMT 时间 #index index.html; &#125; location /nginxdata &#123; #alias /nginxdata/; root /; autoindex on; # 开启目录文件列表 autoindex_exact_size on; # 显示出文件的确切大小，单位是bytes autoindex_localtime on; # 显示的文件时间为文件的服务器时间 charset utf-8,gbk; # 避免中文乱码 &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125; 其中第二个location指定的是该图的路径： nginx命令：启动：nginx关闭： nginx -s quit 此方式停止步骤是待nginx进程处理任务完毕进行停止 nginx -s stop 此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程重新加载配置：nginx -s reload 可能遇到的错误排查： 1.最重要的就是查看自己的路径和端口是不是有问题。 2.检查nginx使用的Linux的端口是否未开启，一般错误样子为下图：解决：打开端口：/sbin/iptables -I INPUT -p tcp –dport 8080 -j ACCEPT 3.403问题,查看Linux的selinux服务是否关闭：解决办法：getenforce查看状态：Enforcing为开启，Permissive为关闭。使用 setenforce 0 命令关闭selinux服务，再次访问成功。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx.conf</tag>
        <tag>nginx搭建服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（pycharm）添加chrome环境变量]]></title>
    <url>%2F2019%2F%EF%BC%88pycharm%EF%BC%89%E6%B7%BB%E5%8A%A0chrome%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[报错信息可能为：selenium.common.exceptions.WebDriverException: Message: ‘chromedriver’ executable needs to be in PATH 解决： 打开chrome 输入 “chrome://version/”来查看chrome版本。 下载对应的chromedriver驱动：http://chromedriver.storage.googleapis.com/index.html对应版本可参考例如我的chrome版本是77.0.3865.90，我下了一个接近的版本 77.0.3865.40（没有我的指定版本。。） 将Chromedriver加入到PATH（记住环境变量添加完成后重启pycharm生效）https://www.jianshu.com/p/7713743ac687 重启后，再次运行项目，OK。 ————————————————分割线————————————– 比如我的python代码： 12345# coding=utf-8from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&apos;http://www.baidu.com/&apos;)]]></content>
      <categories>
        <category>Python </category>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>chrome环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以流的形式批量下载]]></title>
    <url>%2F2019%2F%E4%BB%A5%E6%B5%81%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[压缩包的形式下载文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141package com.controller.task;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import com.bocloud.cmc.utils.DefaultHeader;import com.bocloud.common.enums.BoCloudMethod;import com.bocloud.common.enums.BoCloudService;import com.bocloud.common.model.BocloudResult;import com.bocloud.common.utils.Common;import com.bocloud.common.utils.JSONTools;import com.bocloud.service.http.core.ServiceFactory;import com.bocloud.service.http.model.RemoteService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.net.URLEncoder;import java.util.HashMap;import java.util.Map;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;@RestController@RequestMapping("/script")@Api(value = "脚本管理", tags = "脚本管理")public class ScriptController &#123; private static Logger logger = LoggerFactory.getLogger(ScriptController.class); private final String PATH = "/script"; private BoCloudService SERVICE = BoCloudService.Cop; @Autowired private ServiceFactory serviceFactory; /* 批量导出脚本 */ @ApiOperation(value = "脚本批量导出", response = BocloudResult.class, httpMethod = "GET", produces = MediaType .APPLICATION_JSON_VALUE) @RequestMapping(value = "/batchExport", method = &#123;RequestMethod.GET&#125;) public BocloudResult batchExport(@RequestParam(value = Common.PARAMS, required = false) String params, HttpServletRequest request, HttpServletResponse response) &#123; JSONObject jsonObject = JSONTools.isJSONObj(params); String ids = jsonObject.getString("ids"); @SuppressWarnings("unchecked") Map&lt;String, Object&gt; sorterMap = new HashMap&lt;&gt;(); sorterMap.put("ids", ids); RemoteService service = serviceFactory.safeBuild(SERVICE, PATH + "/batchExport", BoCloudMethod.SUBOBJ, DefaultHeader.header(), sorterMap, request); BocloudResult result = service.invoke(); if (result.isSuccess()) &#123; String content = JSONObject.toJSONString(result.getData()); JSONObject object = JSONObject.parseObject(content); String zipName = "脚本" + System.currentTimeMillis() + ".zip"; response.setCharacterEncoding("utf-8"); try &#123; response.setHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(zipName, "UTF-8")); &#125; catch (UnsupportedEncodingException e) &#123; logger.error("UnsupportedEncodingException：", e); &#125; JSONArray scripts = JSONArray.parseArray(object.getString("rows")); ZipOutputStream zipOutput = null; try &#123; zipOutput = new ZipOutputStream(new BufferedOutputStream(response.getOutputStream())); &#125; catch (FileNotFoundException e) &#123; logger.error("FileNotFoundException:", e); &#125; catch (IOException e) &#123; logger.error("FileNotFoundException:", e); &#125; BufferedInputStream bis = null; int read; for (Object script : scripts) &#123; JSONObject jObj = (JSONObject) JSONObject.toJSON(script); String contentScript = jObj.getString("content"); String scriptName = jObj.getString("name"); String fileName = ""; //获得要下载的文件名 try &#123; String fname = "脚本-" + scriptName + "_" + System.currentTimeMillis() + ".txt"; fileName = URLEncoder.encode(fname, "UTF-8"); final String userAgent = request.getHeader("USER-AGENT"); if (StringUtils.contains(userAgent, "Mozilla")) &#123; fileName = new String(String.valueOf(fname).getBytes(), "UTF-8"); &#125; &#125; catch (UnsupportedEncodingException e) &#123; logger.error("UnsupportedEncodingException:", e); &#125; try &#123; ZipEntry zEntry = new ZipEntry(fileName); assert zipOutput != null; zipOutput.putNextEntry(zEntry); bis = new BufferedInputStream(new ByteArrayInputStream(contentScript.getBytes())); byte[] buffer = new byte[1024]; while ((read = bis.read(buffer)) != -1) &#123; zipOutput.write(buffer, 0, read); &#125; &#125; catch (IOException e) &#123; logger.error("Download fail:", e); &#125; finally &#123; try &#123; if (bis != null) &#123; bis.close(); &#125; if (zipOutput != null) &#123; zipOutput.close(); &#125; &#125; catch (IOException e) &#123; logger.error("bis AND zipOutput：", e); &#125; try &#123; //删除压缩包 File zfile = new File(zipName); zfile.delete(); &#125; catch (Exception e) &#123; logger.error("删除压缩包失败：", e); &#125; &#125; &#125; return new BocloudResult(true, "导出成功"); &#125; else &#123; return result; &#125; &#125;&#125; 注意：如果把文件new一次，本地就会在下载后生成一个文件，如果不想保存文件，则需要建文件以流的形式传输。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java以流的形式批量下载</tag>
        <tag>java压缩包下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware Player15序列号]]></title>
    <url>%2F2019%2FVMware-Player15%E5%BA%8F%E5%88%97%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[VMware Player15序列号： AU558-D0G0Q-M84HZ-UEM5E-Q3RXA UV3H2-8ZX5K-M81HP-14YN9-XLRCA YZ5E2-DQFE5-M8DLQ-VPPQX-NPHAA VG3E0-6JX8K-480QQ-QXW5E-XKUA6 GC7RK-01G53-H854Q-7DWGZ-MPRZ8]]></content>
      <categories>
        <category>Mixed</category>
      </categories>
      <tags>
        <tag>VMware Player15序列号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql授权数据库（或表）给用户]]></title>
    <url>%2F2019%2Fmysql%E6%8E%88%E6%9D%83%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E6%88%96%E8%A1%A8%EF%BC%89%E7%BB%99%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[授权所有的数据库和表给所有的用户GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;passwd&#39; WITH GRANT OPTION; 授权所有的db数据库的table表给所有的用户GRANT ALL PRIVILEGES ON db.table TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;passwd&#39; WITH GRANT OPTION; 删除某个用户的所有权限：DELETE FROM user Where User=’test’ and Host=’localhost’; 刷新数据库flush privileges; 查询表权限select User, host from mysql.user;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper java.net.ConnectException: 拒绝连接 (Connection refused)]]></title>
    <url>%2F2019%2Fzookeeper-java-net-ConnectException-%E6%8B%92%E7%BB%9D%E8%BF%9E%E6%8E%A5-Connection-refused%2F</url>
    <content type="text"><![CDATA[首先说一下网上我查到的解决方案：https://blog.csdn.net/qq_34841911/article/details/79165778但是并没有解决我的问题。 我的方案： 查看zookeeper的dataDir（数据）和dataLogDir（日志）目录，重启zk就可以了。 123rm -rf dataDir目录/*rm -rf dataLogDir目录/*ZOOK_HOME/bin/zkServer.sh start]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git分支合并分支]]></title>
    <url>%2F2019%2Fgit%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[将Branch3的代码合并到Branch1上，需要用到 git merge 12git checkout Branch1 # 切换到Branch1分支git merge Branch3 # 将Branch3分支内容更新到Branch3分支 Idea：切换到Branch1，选择Branch3的merge 如果你想在Branch2上更新Branch1的提交，需要用到 git rebase 12git checkout Branch2 # 切换到Branch2分支git rebase Branch1 # 将Branch1分支内容更新到Branch1分支]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git合并分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jira搭建教程]]></title>
    <url>%2F2019%2Fjira%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[感谢bloger，感谢百度 Code研究者-jira搭建部署 小小飞侠-linux下安装jira 许可证地址]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>jira搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[共享-上课笔记]]></title>
    <url>%2F2019%2F%E5%85%B1%E4%BA%AB-%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一天运行 编译：javac -cp 目标目录 源文件的全路径（例如：javac -cp c:/java c:/java/test.java） 运行：java -cp class文件所在目录 类名称（例如：java -cp c:/java HelloWorld） 类与公开类 如果一个类是公开类，.java文件名字与公共类名字一致 一个.java文件只应该有一个公开类 生成帮助文档 javadoc -d 目标文件 源文件(例如：javadoc -d c:/java/help c:java/Note.java） 在其文件夹内运行，可简化为： javadoc -d help Note.java 第二天全局变量和局部变量的区别 全局变量（成员变量）可以不用初始化值，其默认值为0，局部变量必须初始化值。（即：局部变量必须先定义再赋值后使用） 面试题 x += y与x = x + y不完全等价 byte b = 0;b =b + 1;不正确****b += 1;正确 以下哪一个数据类型不能作用在switch case语句当中：A 枚举 B Sting C int D long E byte F char选D 第三天 for一般应用于固定次数的循环，while一般应用于不固定次数的循环 使用lable可跳出多重循环 for循环增强（foreach），jdk1.5版本的遍历（迭代） 数组 数组所创建的内存空间只能存储相同类型的数据 数组所分配的内存空间是连续的 数组所分配的内存空间是不可扩充的 第四天基本数据类型byte short char int long float double boolean类类型Byte Short Character Integer Long Float Double Boolean升序排列(使用元素自然的顺序排列)Arrays.sort(数组名);降序排列（自定义排列顺序）Arrays.sort(数组名,Collections.reverseOrder()); reverseOrder为倒序 汉语排序Collator.getInstance(Locale.CHINA);数组拷贝// 执行拷贝(原数组，从原数组的第n位取元素，目标数组，从目标数组的第n位开始装入，拷贝原数组多少位) System.arraycopy(array, 0, newArray, 1, array.length);第五天线性结构的四大特征有序的，连续的，随机访问的，插入和删除慢 函数的概念函数是一个固定的程序段，它在可以实现固定运算的同时，带有一个入口和一个出口 函数的定义方法+功能+动作 函数的语法返回值类型 函数名 (函数类型 参数名称1，函数类型 参数名称2) { 函数体 }命名规范 包名：所有单词中的字母均小写，例如：java.util 类名：所有单词的首字母大写，其他字母小写，例如：StudentService 变量名称和方法名称：第一个单词的首字母小写，其他所有单词首字母大写，例如：stuName 常量：所有单词的所有字母全部大写，单词和单词之间用下划线分隔，例如：PI,STU_SEX_MAN 第六天第七天面向对象 构造方法的意义：给对象的数据(属性)进行初始化 构造方法不用调用，一创建对象就执行 如果在一个类中没有定义构造方法，系统会默认给一个空参的构造方法，格式是：public 类名(){} 如果在一个类中定义了一个有参的构造方法，系统就不会默认再给空参的构造方法 有参的构造方法是为了给对象中的属性进行初始化，空参在不需要给属性进行初始化，但是还要创建对象的时候使用 面向对象的四大特征抽象 对现实世界进行抽象，形成类 研究事物的静态特征 研究事物的动态特征 类的对象之间的转换（产生对象之后就可以调用属性和方法） 封装 提供构造方法 静态块（做类的初始化工作） 控制访问（private,default,protected,pubulic）(控制构造方法，控制属性的访问，控制方法的访问) 继承 在遵守控制访问的前提下，子类能继承父类当中的属性(静态特征)和方法（动态特征） 继承父类的属性（公开的和受保护的） 继承父类的方法（公开的和受保护的） 父子类在同一包当中，default也可以继承 多态动态是指同一个动作，作用在相同或不同的对象之间拥有不同的解释. 重载，同一个类当中多态的体现（编译时多态） 重写,父子类当中多态的体现（运行时多态） 多态的机制： 声明父类型的引用指向具体子类型的一个实例 运行时才去绑定 运行时可变 第八天第九天 父类方法加abstract的原因是跟子类表明自己不会(不能实现)这个方法，强制子类重写这个方法 接口本来就是抽象的，可省略abstract不写 第十二天面试题 StringBuilder 在多线程下不能保证数据的安全(没有同步)，效率高 StringBuffer 在多线程下不能保证数据的安全(同步)，效率低 第十三天面试题 String str1 = “abc”; String str2 = new String(“abc”); Integer i1 = 128; Integer i2 = 128; String str3 = “a”; String str4 = “a”; System.out.println(str1.equals(str2));// true System.out.println(str1 == str2);// false System.out.println(i1 == i2);// false System.out.println(i1.equals(i2));// ture System.out.println(str3 == str4);// ture System.out.println(str3.equals(str4));// ture 类的调用公式1.普通类的调用 类名称 变量名称 = new 类名称();2.多态的调用 父类名称 变量名称 = new 子类名称(); 抽象类名称 变量名称 = new 子类名称(); 接口名称 变量名称 = new 子类名称();3.内部类的调用 3.1 成员内部类 外部类名称.内部类名称 变量名称 = new 外部类名称().new 内部类名称();3.2 静态成员内部类 外部类名称.内部类名称 变量名称 = new 外部类名称.内部类名称();3.3 局部内部类 类名称 变量名称 = new 类名称();3.4 匿名内部类 1.抽象类名称 变量名称 = new 抽象类名称(){ //重写抽象方法 }; 2.接口名称 变量名称 = new 接口名称(){ //重写抽象方法 };策略模式定义了算法族，分别封装起来，让它们之间可以互相替换（利用到了多态），此模式让算法的变化独立于使用算法的客户 多态 ==&gt; 面向接口编程 interface 工厂方法一种常用的对象创建型设计模式，此模式的核心精神是封装类中不变的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的 第十四天单例模式对象创建型的模式，把创建对象的责任掌握在自己手中（往回拉） 官方定义：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例 饿汉模式 无论这个实例有没有被外部使用，一律创建 例如：private static OnlineUser onlineUser = new OnlineUser(); 懒汉模式 啥时候用啥时候创建 例如：private static OnlineUser onlineUser; 迭代器模式提供一种方法顺序访问一个聚合（集合）对象中的各种元素，而又不暴露该对象的内部表示 官方定义：当你需要访问一个聚合对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑使用迭代器模式。另外，当需要对聚集有很多种方式遍历时，可以考虑去使用迭代器模式。迭代器模式为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口 多态的实现方式 实体类实现(entity) class IntArray implements Iteerator&lt;Integer&gt; {//重写接口当中的抽象的方法} 1. new IntArray(); 匿名类实现 class ? implements Iterator&lt;Integer&gt; {//重写接口当中抽象的方法} 2. new Iterator&lt;Integer&gt;(){//重写接口当中抽象的方法}； Iterable: Iterator iterator(); //抽象的 Iterator: boolean hasNext(); boolean next(); 面向对象(成员变量和局部变量的区别)成员变量和局部变量：成员变量所属于对象，要看是否是对象的特性，比如人，人的姓名，年龄等局部变量所属于方法，要看方法执行的时候，是否需要，如果需要就定义，好处是方法运行后就消失 成员变量： 类中方法外（位置），堆内存(成员变量属于对象，对象进堆内存)，有默认初始化值，随着对象的调用而存在，随着对象的消失而消失 局部变量： 方法内定义或方法上声明（位置），栈内存(局部变量属于方法，对象进栈内存)，没有默认初始化值，随着方法的调用而创建，随着方法的调用完毕（弹栈）而消失 注意事项：局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。 构造方法和setXxx方法的区别 (构造方法Student s = new Student();) 1.构造方法是用来给对象中的属性进行初始化的2.setXxx是用来修改属性值的，在原对象的基础上 static共性用静态，特性用非静态 第十五天泛型的用法: 1.泛型可以声明在类上面，也可以声明在方法上面2.一个类可以有多个泛型，一个方法也可以有多个泛型3.类在实例化之前必须指明泛型的具体类型4.使用extends表示子类，super表示父类，?表示通配符 第十六天Comparable =&gt; 实现了此接口的类的元素，拥有自然的顺序 int comparaTo(T obj); ComParator =&gt; 此比较器规定了元素自定义的顺序 int compare(T obj1, T obj2);无限级分类 面向的对象 抽象 封装 继承 双链表 递归 第十七天 HashSet无序 所有的set当中的元素都不能重复，只能放一份儿 HashiSet中庸 面试题1.下面哪个集合类能保证以FIFO的顺序取出对象？ A java.util.ListB java.util.LinkedHashSetC java.util.HashSetD java.util.TreeSet 选B 解析：A List是接口C 无序的D 不是先进先出，是按照元素自然的顺序输出，或者加上排序器自定义顺序输出 2.HashSet,LinkedHashSet,TreeSet的区别 顺序：HashSet无序，LinkedHashSet有序(先进先出),TreeSet有序(自然顺序，自定义顺序) 能否放null值： Hash和LinkedHashSet能且只能放一个null值 TreeSet当中只有一个元素的时候，能放null值，大于一个的时候不可以放(会比较，产生空指针异常) 3.ArrayList比LinkedList寻址(访问)快 错：缺少随机两个字，应该是随机寻址快 4.List是有序的 错：List是接口，方法全是抽象的，可以说List的子类全是有序的 5.Set是无序的 错：Set是接口，它的子类，HashSet是无序的，LinkedHashSet和TreeSet是有序的 6.List, Set, Map是否继承了Collection接口？ 错：Map没有继承 7.Collection和Collcetions的区别？ Collection是接口，是集合类当中顶层接口，Collections是类，类中定义了很多跟集合类有关的静态方法 8.Set怎样去重复 Set当中的位置由hashCode()决定， 去重需要两个方法：int hashCode();和 boolean equals() 去重的保留：都只保留最后一个 第十八天Map中的key决定了Entry的位置 单线程选择HashMap(无序，快)，多线程选择Hashtable(有序，不会出错) Set与Map的关系：Set是一个特殊的Map，只有key，没有value的Map 第十九天 线程2种实现方法： 1.java.lang.Thread为java中的线程类，也就是说在java中实现线程要继承Thread 2.实现java.lang.Runnable接口 线程的状态 1.创建 2.就绪（可调用） 3.运行 4.等待/睡眠，阻塞 5.死亡 要保证锁定一定会被释放，就必须将unLock()放到finally{}中 异常捕捉格式： try{ //可能产生异常的代码段 }catch(异常类型1 e){ //处理异常 }catch(异常类型2 e){ //处理异常 } finally{ //无论有无异常都将执行的代码（任何情况都会执行） } try/catch: 一个try语句可以跟多个catch语句。 catch异常时，先捕捉子类异常，再捕捉父类异常。否则会编译无法通过，报无法到达的捕捉块错误。 try，catch，finally必须紧跟，中间不能写除了注释之外的任何代码。 catch不能和finally同时省略。 throw和throws的区别 throw(抛出异常),用于向上抛异常，作用在catch语句当中。throws(声明方法体会抛出哪些异常)，用于声明方法体所抛出的异常,作用在方法上面。 throws :1.throws(声明方法体会抛出哪些异常)，用于声明方法体所抛出的异常,作用在方法上面。 2.throws子句中同时可以指明多个异常，之间用逗号隔开。 3.如果声明了要抛出的异常，则本方法可以不处理，而由调用者处理。 4.throws在向上抛的时候，可以向上抛抽象的异常（异常子类的父类）。 5.若代码显式向上throw 异常时，则必须显式声明throws异常。 第二十天 字符流： read() 1.返回字符对应的ascii码(&gt;=0) 2.当读取到末尾的时候，返回-1 read(char[] chars) 1.返回读取的字符数 2.当读取到文件末尾时返回-1 字节流： read() 1.返回的int(byte) [0,255] 2.当读取到文件末尾时返回-1 read(byte[] b) 1.返回读取的字节数 2.当读取到文件末尾时返回-1 InputStream: 我们把能够读取一个字节序列的对象称为输入流;Java中用java.io.InputStream来描述输入流基类 OuputStream: 我们把能够写入一个字节序列的对象称为输出流。java.io.OuputStream来描述输出流的基类 第二十一天int强转byte：重复的：直接拿走 溢出的：int型取反加一得出byte型int byte(取反加一) Data:byte char short int long float double String 四个地址的区别： 192.168.1.100 =&gt; 路由器给分配的IP127.0.0.1 =&gt; 本机的IPlocalhost =&gt; 域名http://www.baidu.com =&gt; 万维网给的域名 第二十二天使用sql语句的优点:可以复用，不用再手动创建 #进入数据库 数据定义语言DDL(Data Definition Language):用于创建对象，如：create table,alter table,drop table,create view,rename 数据操纵语言DML(Data Manipulation Language)：如insert into,update,delete,select 当字段的值当中出现了单引号’时，用单引号’对单引号’进行转译,与Java中的\转译类似 算术运算符 + - * / 优先级： 乘和除的运算优先级高于加和减 优先级相同的运算符是从左到右进行运算的 可以使用小括号强制语句做出有限运算，并使语句运算顺序更为清晰 日期计算，也可以使用+ -，单位为天(如：select sysdate + 1 from dual) 连接运算符||或concat(arg1, arg2) 比较运算符&lt;,&gt;,&lt;=,&gt;=,=,!=,&lt;&gt;,is,is not,in,not in,between,like,any,all like(包含)：匹配运算符，只能用在字符串中in：匹配列表值 –% 通配符 匹配0个或无数个任意字符–_ 通配符 匹配0个或1个任意字符 添加数据 BEGIN FOR i in 1..50 loop INSERT into t_stu values(seq_stu.nextval,&apos;学生&apos; || i,i,&apos;001&apos; || i,&apos;&apos;,0,i,1); end loop; END;导出数据 用户 创建用户名和密码 creat user ORACLE(用户名) identified by oracle(密码); 为用户授予dba权限 grant dba to ORACLE with admin option; 对象(表，序列，存储过程，触发器，同义词，视图……) 工具==&gt;导出用户对象 存储数据 工具==&gt;导出表 笛卡儿积{1，2} * {3，4，5}{13，14，15，23，24，25} union与union的区别：union去重，稍微慢一点儿 表合并的前提条件：总列数一样，列类型一样，列名一样 –查询所有的学生,并按导师分组，显示每个组里面的平均年龄，最大学号，最晚入学日期，并显示导师的姓名，性别，年龄–MAX(t.teacher_sex),MAX(t.teacher_age),因为是同一个老师，所以性别唯一，取一个就行，用随便一个组函数就行，比如max或min SELECT AVG(s.stu_age),MAX(s.stu_code),MAX(s.stu_entry_date),t.teacher_id teacher_id,MAX(t.teacher_sex),MAX(t.teacher_age) FROM t_student3 s LEFT JOIN t_teacher3 t ON t.teacher_id = s.teacher_id GROUP BY t.teacher_id;七周三天properties：键值对都是字符串的Map 标识符无效：表名或列名错误 Exception in thread “main” java.lang.ExceptionInInitializerError的原因：一般是路径错了 ORA-01747: user.table.column, table.column 或列说明无效sql语句格式不正确 七周五天Integer的值可以为null，int的值不可以为null. 九周一天JavaScript 通过字符串进行属性或方法的访问的时候创建的字符串对象是临时生成的，用完就会自动丢弃，原来的字符串并不会产生改变。 九周三天 String的正则表达式匹配有两个 matches(String regex)：通知此字符串是否匹配给定的正则表达式,参数regex用来匹配此字符串的正则表达式 返回：当且仅当此字符串匹配给定的正则表达式时，才返回 true search(regexp)：如果成功，搜索返回字符串中正则表达式的索引。否则，它返回- 1 正则表达式 []自带或含义，()表示组或优先 十周二天构造函数和原型方式各自的的缺陷：构造函数：getXXX方法一样，每次定义多余原型方式：静态属性XX都一样，太极端 眼睛看不到的值： disabled selected checked readonly [true,false]十周四天XXX（）;和onXXX的区别： submit(): 执行提交 onsubmit: 执行提交完成后，还要执行什么十一周一天基本选择器的复合选择器之间用逗号隔开，取并集 属性选择器的复合选择器之间直接连接，不能有任何符号或空格，取交集 regxp.exe()与regexp.test()的区别 RegExpObject.exec(string)：exec() 方法用于检索字符串中的正则表达式的匹配。检索字符串中指定的值。返回找到的值(该值是从0开始，然后加1(因为是区间))，并确定其位置 RegExpObject.test(string)：test() 方法用于检测一个字符串是否匹配某个模式。检索字符串中指定的值。返回 true 或 false 三种页面初始化方法 1.window.onload = function(){}; 2.$(document).ready(function(){}); 3.$(function(){}); 十一周三天j2ee javaee Java企业版应用j2se javase Java标准版应用 十二周一天重定向：添加，修改，保存，删除查询：查询 1.存在主键外键(引用完整性约束) 1.1 删除教师时，同时删除教师所带的学生 1.2 删除教师时，把教师所带的学生的teacher_id设置为null 在数据库里设置 2.不存在主键外键 2.1 删除教师时，同时删除教师所带的学生 2.2 删除教师时，把教师所带的学生的teacher_id设置为null 在代码中设置 十二周二天request.ContextPath = /项目名称session会话对象： 作用于更广三次握手，第三次开始正式的功能保持时间为30分钟，但是关掉浏览器就直接销毁 取根目录： 链接里写${pageContext.request.contextPath} 重定向里写request.getContextPath 请求转发里不用写，直接在开始加/ page = PageContext request = HttpServletRequest response = HttpServletResponse session = HttpSession（request.getSession();） application = ServletContext config = ServletConfig SQL知识点按照伪序列rownum排序：select page2.* from (select page1.*,rownum rn from (select s.* from T_STUDENT s order by s.stu_id) page1) page2 where rn between ? and ? 起始位置=(当前页号 - 1) * 每页个数 + 1结束位置=当前页号 * 每页个数 总结知识点1.unicode中文码%xx%xx%xx，为什么是六位？ 2.get请求是在head里，post请求是在body里 十四周三天不建外键的原因：环境多，导表麻烦 适合放在缓存中的情况:访问量大，更新次数少，网页缓存一般放在application中 缓存的弊端: 服务器重新启动，才能更新数据，这样太麻烦，所以直接更新缓存，不用重新启动服务器 MyEclipse错误: Failed to initialize end point associated with Protocolhandler [“http-apr-80”] (Socket bind failed:):因为MyEclipse异常退出，tomcat未停止，占用80端口，这时如果再启动tomcat会出现此错误。 控制台error： 无法转换为内部表示：可能是变量的数据类型转换不匹配（比如将Integer转换为String） java.lang.IllegalArgumentException: attempt to create saveOrUpdate event with null entity（尝试用空实体创建saveOrUpdate事件）异常的易被忽略的原因:就是在Action的代码里面缺少实体类的set方法 servelt的4个步骤： 1.接收参数 2.调模型层 3.转发参数 4.做响应：请求转发（或重定向） Hibernate:三个步骤： 1.注册驱动2.执行连接 ==》打开会话 3.编译sql4.执行sql5.从游标中遍历数据 ==》save/update/delete/select 6.关闭游标，statement，连接 ==》关闭会话 Hibernate中FetchMode.JOIN FetchMode.SELECT FetchMode.SUBSELECT介绍 @Fetch(FetchMode.JOIN) 会使用left join查询 只产生一条sql语句@Fetch(FetchMode.SELECT) 会产生N+1条sql语句@Fetch(FetchMode.SUBSELECT) 产生两条sql语句 第二条语句使用id in (…..)查询出所有关联的数据 Strutsstruts基本流程： 1.view：填写正确的控制器连接(eg:/empl/list)2.struts.xml：定义正确的/namespace/active，和要转发的视图(eg:/pages/employee/list.jsp)或要重定向的控制器3.Controller：定义需要调用的方法 struts原理： struts的本质是一个过滤器，将别的控制器(里面所有的请求)都拦截到自己的控制器里。 可做面试题： el表达式：${[‘jiao’]} ${param[‘a’]}与${param.a}:[]里的引号不能省，表示常量，去掉就变成从四大作用域中取a的值 左连接与左外连接，没有区别， save,update与saveOrUpdate：没有区别，saveOrUpdate更方便 杂烩集锦： delete:只设置了id，别的属性没有怎么删的，为甚么不删除员工，因为sql语句：delete from Table where id=？ 集合：Collection包含List,Set，所以尽量用Colletion，包容性好 自增increment不能用于多线程 接口中的修饰符不写默认是public 匿名类在类里执行时的事件一般在做开始，相当于缓存的时间 sql语句： select TEACHER_ID, TEACHER_NAME, TEACHER_AGE, ``TEACHER_SEX, TEACHER_CODE, COLLEGE_ID, TEACHER_LOGO, ATTACHMENT_PATH, ATTACHMENT_NAME from ORACLE.T_TEACHERwhere (TEACHER_NAME like &#39;%&#39; || &#39;&#39;) or (1=1) or ``(teacher_name = &#39;&#39; || &#39;%&#39;) ‘%’ || ‘’ : 做(字符串)与运算,变成’%’(即teacher_name like ‘%’),其中三个括号里的值都是true 数据库翻页查询公式： select pager2.* from ( select pager1.*,rownum rn from ( select * from 表名 order by 列名 )pager1 )pager2 where rn between (pageNo - 1) * (pageCount) + 1 and (pageNo) * (pageCount)数据库循环插值公式： declare i number; begin for i in 1..50 loop insert into 表名 (列名,......) values(列名的值,.....); end loop; end;集合中的参数使用了注解就不能使用默认的名字。 数组越界String index out of range: -1 length,length(),size()详解及区别： length属性:用于获取数组长度。length()方法：用于获取字符串长度。size()方法：用于获取泛型集合有多少个元素。 什么时候用size()?什么时候用length?什么时候用length()? String类有length的方法，数组有length的属性，集合(List)有size的方法 为什么控制器Controller没有spring的标识：因为spring扫描控制器是在spring—mvc.xml里，在web.xml启动时才被spring启用，只有在applicationContext.xml里才会自动加上spring标识 一对多，多对多，更新时： 先全删除以前(旧)的，再添加现在应有(新)的， Springerror:Class’org.springframework.orm.hibernate3.LocalSessionFactoryBean’ not found:没有加Spring 3.1 Persistence Libraries（spring 持久化包）. applicationContext.xml流程： 1.控制器引用Service2.Service引用dao3.dao引用session工厂4.session工厂引用数据源5.数据源查数据库 spring的xml3中注入方式： 1.xml注入2.自动注入(byName,byType)3.注解注入 error:Exception in thread “main” org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named ‘userController’ is defined 文件命名空间，文件位置 byName与byType的区别: byName: beans配置属性default-autowire:”byName” 按照bean的名称(唯一id)， 自动装配property byType: beans配置属性default-autowire:”byType” 按照bean的class类型， 自动装配property(前提是session的default-autowire属性是no)，byType配置不能有两个bean引用的class中有一样的类型的属性，否则报错 使用注解装配步骤： 1.包内加注解: @Controller,申请控制器 @Service,申请service @Repository,申请dao，数据仓库 @Autowired，自动注入2.applicationContext.xml配置: 命名空间： xmlns:context=&quot;http://www.springframework.org/schema/context&quot;schema: xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; 3.告诉spring那些类有注解： applicationContext.xml下配置： &lt;context:component-scan base-package=&quot;要扫描的包含注解的包名(eg:com.oracle.model)&quot; /&gt; 切面编程三个知识点：切面，切点，通知。 反转是由spring给的。 autoWired按照byType，byName 运行时绑定与运行时可变？ 运行时才绑定，运行时才变出来，但可以是任何代理，代理可以不一样，所以是可变 没有ioc就没有aop？ 因为有了控制反转(eg:IUserDao userDao)，才能有切面编程(运行时绑定，运行时可变) SSH:因为ssh，struts和spring会因为控制器而冲突，发生空指针异常，所以需要引struts 2 spring Liability来解决 SSM:Mapper.xml配置中的符号#和$: # 使用了预编译 $ 未使用预编译运行时绑定和可变： 运行时绑定：运行时才会绑定了一个代理 运行时可变：运行时可以有多个代理插入 连接池： 连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用。 连接池主要的优点有：1.减少连接创建时间虽然与其它数据库相比 GBase 提供了较为快速连接功能，但是创建新的 JDBC 连接仍会招致网络和 JDBC 驱动的开销。如果这类连接是“循环”使用的，使用该方式这些花销就可避免。2.简化的编程模式当使用连接池时，每一个单独的线程能够像创建了一个自己的 JDBC 连接一样操作，允许用户直接使用JDBC编程技术。3.受控的资源使用如果用户不使用连接池，而是每当线程需要时创建一个新的连接，那么用户的应用程序的资源使用会产生非常大的浪费并且可能会导致高负载下的异常发生。 数据库连接池的主要操作如下：（1）建立数据库连接池对象（服务器启动）。（2）按照事先指定的参数创建初始数量的数据库连接（即：空闲连接数）。（3）对于一个数据库访问请求，直接从连接池中得到一个连接。如果数据库连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的数据库连接。（4）存取数据库。（5）关闭数据库，释放所有数据库连接（此时的关闭数据库连接，并非真正关闭，而是将其放入空闲队列中。如实际空闲连接数大于初始空闲连接数则释放连接）。（6）释放数据库连接池对象（服务器停止、维护期间，释放数据库连接池对象，并释放所有连接）。 ssm遇到的问题： 认识spring配置的注解：mvc：annotation-driven /表示不拦jsp/*拦所有的文件 struts：多例模式，有成员变量，来一次请求，实例化(new)一次 spring：单例模式(只实例化一次)，没有成员变量, 监听：在servlet初始化的时候，才发起请求，读controller 控制器里的方法上的参数Integer stuId： 写在参数里的参数是aop代理controller接收了参数 java反射： getMethod:必须是public才能找到getDeclaredMethod 声明过就能找到 method.getParameterAnnotations()：获得方法的参数的注解[][] method.getAnnotations()：获得方法的注解[] 文件的位置关系： WebRoot下的文件可以随意访问，这里一般放公共的东西，e WebRoot/WEB-INF下的文件不可以随便访问，这里面放的是配置的文件，只能控制器带着进去 为什么做重定向： 请求转发直奔最后一个环节，没有暴露在互联网下，需要通过查询控制器查到数据，再到视图list.jsp=》controller(XX)=&gt;list=&gt;list.jsp 重定向：“redirect:list”：正确“forward:list”：带参数，错误“student/list”:直奔视图，错误 面试题： jquery对象$()转dom对象： $()[0]$().get(0) dom对象转jquery对象$():$(dom) mybatis 配置文件报错:”Referenced file contains errors(file:/D:/config/ mybatis-3-mapper.dtd)： Widow=&gt;MyEclipse=&gt;Files and Editors=&gt;XML=&gt;XML Catalog=&gt;add… 添加的是mybatis\org\apache\ibatis\builder\xmlmybatis-3-mapper.dtd @JsonIgnore：方法和变量上都可以标注 service和IService一样，为什么要创建两个？ 因为aop需要执行切面编程，aop就是接口service的子类，所以创建IService的意义就在这 保存角色信息步骤：(没有设置，报错为无效列类型111) 1.保存角色 xml配置：使用生成主键useGeneratedKeys=”true”，主键列keyColumn=”role_id”，对应的对象属性keyProperty=”roleId” 2.设置(保存)权限 2.1删除旧权限，2.2保存新权限 拦截的问题：优先走具体的路径(eg:.js,/images/)，再走抽象的路径(/) 打开二级缓存： 1.xxMapper.xml中的mapper下，加上 2.xx.java实现序列化接口 Session缓存： 将信息放到session缓存中，直接登录时查一次]]></content>
      <categories>
        <category>Mixed</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq服务启动失败]]></title>
    <url>%2F2019%2Frabbitmq%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[这个问题是真的难，搜出来的答案是很多，不知道是不是我操作不当，就是不能成功，困扰了我一周得，最终这个问题还是被我解决了，但这个答案并不好找。 错误信息：第一个： 123456789101112131415161718192021222324252627282930313233343536373839[root@cmp_10_20_10_16 bin]# rabbitmqctl statusStatus of node rabbit@cmp_10_20_10_16 ...Error: unable to connect to node rabbit@cmp_10_20_10_16: nodedownDIAGNOSTICS===========attempted to contact: [rabbit@cmp_10_20_10_16]rabbit@cmp_10_20_10_16: * connected to epmd (port 4369) on cmp_10_20_10_16 * epmd reports: node 'rabbit' not running at all other nodes on cmp_10_20_10_16: ['rabbitmq-cli-10'] * suggestion: start the nodecurrent node details:- node name: 'rabbitmq-cli-10@localhost'- home dir: /root- cookie hash: WT5Oi6Xclw17F+Il74FLlg==[root@cmp_10_20_10_16 bin]# rabbitmqctl stopStopping and halting node rabbit@cmp_10_20_10_16 ...Error: unable to connect to node rabbit@cmp_10_20_10_16: nodedownDIAGNOSTICS===========attempted to contact: [rabbit@cmp_10_20_10_16]rabbit@cmp_10_20_10_16: * connected to epmd (port 4369) on cmp_10_20_10_16 * epmd reports: node 'rabbit' not running at all other nodes on cmp_10_20_10_16: ['rabbitmq-cli-97'] * suggestion: start the nodecurrent node details:- node name: 'rabbitmq-cli-97@localhost'- home dir: /root- cookie hash: WT5Oi6Xclw17F+Il74FLlg== 第二个： 12345678910111213141516171819=INFO REPORT==== 18-Nov-2019::10:05:17 ===Error description: &#123;error, &#123;cannot_delete_plugins_expand_dir, ["/var/lib/rabbitmq/mnesia/rabbit@cmp_10_20_10_16-plugins-expand", &#123;cannot_delete, "/var/lib/rabbitmq/mnesia/rabbit@cmp_10_20_10_16-plugins-expand/webmachine-1.10.3/priv/www/index.html", eacces&#125;]&#125;&#125;Log files (may contain more information): /var/log/rabbitmq/rabbit@cmp_10_20_10_16.log /var/log/rabbitmq/rabbit@cmp_10_20_10_16-sasl.logStack trace: [&#123;rabbit_plugins,setup,0,[&#123;file,"src/rabbit_plugins.erl"&#125;,&#123;line,71&#125;]&#125;, &#123;rabbit,broker_start,0,[&#123;file,"src/rabbit.erl"&#125;,&#123;line,280&#125;]&#125;, &#123;rabbit,start_it,1,[&#123;file,"src/rabbit.erl"&#125;,&#123;line,403&#125;]&#125;, &#123;init,start_it,1,[]&#125;, &#123;init,start_em,1,[]&#125;] 解决方案：rm -rf /var/lib/rabbitmq/* (网上的版本： rm /var/lib/rabbitmq/mnesia )，我是把这个目录下的东西全部删除了。 参考：RabbitMQ-1-解决报错：{error, {cannot_delete_plugins_expand_dir cannot_delete-李会刚 其他觉得靠谱的解决方案：https://blog.csdn.net/weixin_34137799/article/details/85876152]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blogger Introduce]]></title>
    <url>%2F2019%2FBlogger-Introduce%2F</url>
    <content type="text"><![CDATA[博主主修Java，辅修* 红桃jiao的个人博客，绘制中 csdn，github，微博]]></content>
  </entry>
  <entry>
    <title><![CDATA[html获取当前项目根路径]]></title>
    <url>%2F2019%2Fhtml%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%A1%B9%E7%9B%AE%E6%A0%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[Spring boot 正常启动 浏览器无法访问Controller，在本地测试是可以访问的，如果放到tomcat中就出现了这个问题。通过浏览器F12查询到url丢失了项目根路径，添加之后成功访问。 获取当前项目根路径： 1234567891011121314151617181920212223242526272829&lt;script type="text/javascript"&gt; //获取项目根路径 function getRootPath_web() &#123; //获取当前网址，如： http://localhost:8083/uimcardprj/share/meun.jsp var curWwwPath = window.document.location.href; //获取主机地址之后的目录，如： uimcardprj/share/meun.jsp var pathName = window.document.location.pathname; var pos = curWwwPath.indexOf(pathName); //获取主机地址，如： http://localhost:8083 var localhostPaht = curWwwPath.substring(0, pos); //获取带"/"的项目名，如：/uimcardprj var projectName = pathName.substring(0, pathName.substr(1).indexOf('/') + 1); // 打印获取当前项目根路径 console.log(getRootPath_web()); return (localhostPaht + projectName); &#125; $("#increaseInput").click(function () &#123; $.ajax(&#123; // 这里在controller的url之前加上根路径，即可成功访问 url: getRootPath_web() + "/increaseInput", data: $("#increaseInput").value, success: function (result) &#123; console.log(result); &#125; &#125;) &#125;);&lt;/script&gt; 感谢bloger： Hgihness-https://blog.csdn.net/javahighness/article/details/52515226，idea构建war包 oldmonk-https://www.cnblogs.com/xujingyang/p/7607212.html 星朝-https://www.cnblogs.com/jpfss/p/9042249.html（虽然很厉害，但是没看懂）]]></content>
      <categories>
        <category>html&amp;css&amp;js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 主题备份问题]]></title>
    <url>%2F2019%2FHexo-%E4%B8%BB%E9%A2%98%E5%A4%87%E4%BB%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一般备份hexo目录是，发现主题并没有提交上去，如下图： 解决方式如下： git rm –cached themes/next/ rm &apos;themes/next&apos; git status On branch master Your branch is up to date with &apos;origin/master&apos;. Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: themes/next Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) themes/ git add themes/next/ git status On branch master Your branch is up to date with &apos;origin/master&apos;. Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: themes/next new file: themes/next/.all-contributorsrc new file: themes/next/.editorconfig new file: themes/next/.eslintrc.json new file: themes/next/.gitattributes` ...... git commit -m “备份next主题” [master 2386fe5] 备份next主题 347 files changed, 27937 insertions(+), 1 deletion(-) delete mode 160000 themes/next create mode 100644 themes/next/.all-contributorsrc create mode 100644 themes/next/.editorconfig ...... git push origin master Enumerating objects: 418, done. Counting objects: 100% (418/418), done. Delta compression using up to 4 threads Compressing objects: 100% (400/400), done. Writing objects: 100% (416/416), 761.18 KiB | 3.49 MiB/s, done. Total 416 (delta 27), reused 0 (delta 0) remote: Resolving deltas: 100% (27/27), completed with 1 local object. To https://github.com/jiaoht/HexoDemoBac.git e495fcb..2386fe5 master -&gt; master]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git总结]]></title>
    <url>%2F2019%2Fgit_command%2F</url>
    <content type="text"><![CDATA[如有错误，斧正不甚感激 总结来自廖雪峰老师的官方网站Git教程 配置用户名和密码： 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; git init：把当前目录变成Git可以管理的仓库 git add xx：将文件xx添加到暂存区，可反复多次使用，添加多个文件 git commit -m “xx”：将暂存区所有文件提交到仓库 git status：查看仓库当前的状态 git diff xx：查看xx文件都做过哪些修改操作 git log( –pretty=oneline)：显示从最近到最远的提交日志(简行显示) git reset –hard (HEAD^/版本号)：回退到(上一个/某个)版本 git reflog：记录所有历史版本号 git diff HEAD – xx：查看工作区和版本库里面最新版本的区别 git checkout – file：丢弃工作区的修改 git rm xx：删除xx文件(之后执行git commit提交完成) 配置公钥： 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 连接远程仓库： 1git remote add origin git@github.com:jiaoht/learngit.git git push -u origin master：把本地库的所有内容推送到远程库上(第一次推送master分支时，加上-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令) git clone git@github.com:jiaoht/gitskills.git：从远程库克隆到本地库 git checkout：命令加上-b参数表示创建并切换，相当于以下两条命令： git branch dev：创建分支 git checkout dev：切换分支 git branch：命令会列出所有分支，当前分支前面会标一个*号 git merge：命令用于合并指定分支到当前分支 git branch -d xx：删除xx分支 git log –graph( –pretty=oneline –abbrev-commit)：命令可以看到分支合并图 git merge –no-ff：用普通模式合并，合并后的历史有分支，能看出来曾经做过合并 git stash：把当前工作现场“储藏”起来，等以后恢复现场后继续工作 git stash list：列出工作现场 git stash pop：恢复工作现场的同时把stash内容也删了，相当于： git stash apply：只恢复，不删除stash git stash drop：删除stash git branch -D name：强行删除，删除该分支时前须先切换到其他分支 git remote( -v)：查看远程库的信息(更详细的信息) git push origin xx：推送xx分支 git checkout -b dev origin/dev：同事创建远程origin的dev分支到本地 git branch –set-upstream branch-name origin/branch-name：建立本地分支和远程分支的关联 git pull：抓取远程的新提交 git tag tagname：新建标签，默认为HEAD，也可以指定commit id git tag -a tagname -m “blablabla…”：指定标签信息 git tag：查看所有标签 git push origin tagname：推送一个本地标签 git push origin –tags：推送全部未推送过的本地标签 git tag -d tagname：删除一个本地标签 git push origin :refs/tags/tagname：删除一个远程标签 注意事项： HEAD指向的版本就是当前版本. 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to branch-name origin/branch-name。 git rebase操作可以把本地未push的分叉提交历史整理成直线，使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比 总结来自来自易百的Git教程 这一部分属实看的不是很懂，其实上面的大概已经够用了，这部分可不看 Gitee总结： echo ‘This is my first Git control file ‘ &gt; mytext.txt：新建的mytext.tex文件，将这句话放到文件中 git status (-s/–short)：简行命令(未跟踪??,修改未暂存区:右M,修改入暂存区:左M,工作区被修改提交到暂存区后工作区中又被修改MM,暂存区A,文件重命名R,文件已从本地存储库中删除D) git add . ：将所有文件暂存 git commit -a：加参数-a,直接跳过git add进行提交 git commit –amend：修改(覆盖)最后一次提交 git mv a b：把a文件命名为b,相当于： mv a b git rm a git add b git log -p -2：p用来显示每次提交的内容差异,仅显示最近两次提交 git log –stat：显示每次提交的简略的统计信息 git log –pretty=oneline(short/full/fuller/format)：指定使用不同于默认格式的方式展示提交历史，本次为显示在一行 git log –pretty=format:”%h %s” –graph：graph用ASCII字符串来显示分支 git remote show origin：查看远程仓库信息 git remote rename a b：远程仓库重命名 git remote rm：远程仓库移除 git branch -m oldname newname：重命名分支 git config -–add site.name jiaoht：添加配置项 git config –[local|global|system] -–unset xx：删除xx配置项 git add *Controller：将以Controller结尾的文件的所有修改添加到暂存区 git add Hello*：将所有以Hello开头的文件的修改添加到暂存区 git add Hello?：将以Hello开头后面只有一位的文件的修改提交到暂存区 git add -[u|A|i] []： u：把中所有跟踪文件中被修改过或已删除文件的信息添加到索引库，省略表示 . ,即当前目录 A：把所有跟踪文件中被修改过或已删除文件和所有未跟踪的文件信息添加到索引库，省略表示 . ,即当前目录 i：查看被所有修改过或已删除文件但没有提交的文件，并通过其revert子命令可以查看中所有未跟踪的文件，同时进入一个子命令系统 git status -uno：只列出所有已经被git管理的且被修改但没提交的文件 git diff ：比较当前文件和暂存区文件差异 git diffgit diff ：比较两次提交之间的差异 git diff ：在两个分支之间比较 git diff –[staged|cached]：比较暂存区和版本库差异 git diff –stat：仅仅比较统计信息 git text.txt mydir：将ext.txt 移动到 mydir，相当于： mv test.txt mydir/ git rm test.txt git add mydir git log –pretty=format:”%an %ae %ad %cn %ce %cd %cr %s” –graph常见的format选项： #选项 #说明 %H 提交对象(commit)的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象(tree)的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象(parent)的完整哈希字串 %p 父对象的简短哈希字串 %an 作者(author)的名字 %ae 作者的电子邮件地址 %ad 作者修订日期(可以用 -date= 选项定制格式) %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 --graph 显示分支 git log –before={3,weeks,ago} –after={2018-04-18}： –after 仅显示指定时间之后的提交(不包含当前日期) –before 仅显示指定时间之前的提交(包含当前日期) git push –all origin：将本地的所有分支都推送到远程主机 git push origin –tags：向远程推送标签 git push origin tag_name：推送单个标签 git push origin :tag_name：删除单个标签 git remote add [shortname] [url]：添加一个新的远程仓库，和简名 git rebase：把一个分支的修改合并到当前分支(没怎么看懂) 注意事项：git fetch和git pull的区别 git fetch：相当于是从远程获取最新版本到本地，不会自动合并。 $ git fetch origin master $ git log -p master..origin/master $ git merge origin/master 以上命令的含义： 首先从远程的origin的master主分支下载最新的版本到origin/master分支上 然后比较本地的master分支和origin/master分支的差别 最后进行合并 上述过程其实可以用以下更清晰的方式来进行： $ git fetch origin master:tmp $ git diff tmp $ git merge tmp git pull：相当于是从远程获取最新版本并merge到本地 git pull origin master 上述命令其实相当于git fetch 和 git merge 在实际使用中，git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。常用操作： 为现有的代码库启动一个新的Git仓库： cd path：转到该路径下 git init：创建一个/path/.git目录 git add . ：将所有现有文件添加到索引 git commit . -m &quot;a commit message&quot;：将原始状态记录为历史的第一个提交]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
